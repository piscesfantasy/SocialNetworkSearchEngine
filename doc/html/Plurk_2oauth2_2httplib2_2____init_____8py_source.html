<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ver_20120624/Plurk/oauth2/httplib2/__init__.py Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>ver_20120624/Plurk/oauth2/httplib2/__init__.py</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="keyword">from</span> __future__ <span class="keyword">import</span> generators
<a name="l00002"></a>00002 <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00003"></a>00003 <span class="stringliteral">httplib2</span>
<a name="l00004"></a>00004 <span class="stringliteral"></span>
<a name="l00005"></a>00005 <span class="stringliteral">A caching http interface that supports ETags and gzip</span>
<a name="l00006"></a>00006 <span class="stringliteral">to conserve bandwidth.</span>
<a name="l00007"></a>00007 <span class="stringliteral"></span>
<a name="l00008"></a>00008 <span class="stringliteral">Requires Python 2.3 or later</span>
<a name="l00009"></a>00009 <span class="stringliteral"></span>
<a name="l00010"></a>00010 <span class="stringliteral">Changelog:</span>
<a name="l00011"></a>00011 <span class="stringliteral">2007-08-18, Rick: Modified so it&#39;s able to use a socks proxy if needed.</span>
<a name="l00012"></a>00012 <span class="stringliteral"></span>
<a name="l00013"></a>00013 <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 __author__ = <span class="stringliteral">&quot;Joe Gregorio (joe@bitworking.org)&quot;</span>
<a name="l00016"></a>00016 __copyright__ = <span class="stringliteral">&quot;Copyright 2006, Joe Gregorio&quot;</span>
<a name="l00017"></a>00017 __contributors__ = [<span class="stringliteral">&quot;Thomas Broyer (t.broyer@ltgt.net)&quot;</span>,
<a name="l00018"></a>00018     <span class="stringliteral">&quot;James Antill&quot;</span>,
<a name="l00019"></a>00019     <span class="stringliteral">&quot;Xavier Verges Farrero&quot;</span>,
<a name="l00020"></a>00020     <span class="stringliteral">&quot;Jonathan Feinberg&quot;</span>,
<a name="l00021"></a>00021     <span class="stringliteral">&quot;Blair Zajac&quot;</span>,
<a name="l00022"></a>00022     <span class="stringliteral">&quot;Sam Ruby&quot;</span>,
<a name="l00023"></a>00023     <span class="stringliteral">&quot;Louis Nyffenegger&quot;</span>]
<a name="l00024"></a>00024 __license__ = <span class="stringliteral">&quot;MIT&quot;</span>
<a name="l00025"></a>00025 __version__ = <span class="stringliteral">&quot;0.7.4&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">import</span> re
<a name="l00028"></a>00028 <span class="keyword">import</span> sys
<a name="l00029"></a>00029 <span class="keyword">import</span> email
<a name="l00030"></a>00030 <span class="keyword">import</span> email.Utils
<a name="l00031"></a>00031 <span class="keyword">import</span> email.Message
<a name="l00032"></a>00032 <span class="keyword">import</span> email.FeedParser
<a name="l00033"></a>00033 <span class="keyword">import</span> StringIO
<a name="l00034"></a>00034 <span class="keyword">import</span> gzip
<a name="l00035"></a>00035 <span class="keyword">import</span> zlib
<a name="l00036"></a>00036 <span class="keyword">import</span> httplib
<a name="l00037"></a>00037 <span class="keyword">import</span> urlparse
<a name="l00038"></a>00038 <span class="keyword">import</span> urllib
<a name="l00039"></a>00039 <span class="keyword">import</span> base64
<a name="l00040"></a>00040 <span class="keyword">import</span> os
<a name="l00041"></a>00041 <span class="keyword">import</span> copy
<a name="l00042"></a>00042 <span class="keyword">import</span> calendar
<a name="l00043"></a>00043 <span class="keyword">import</span> time
<a name="l00044"></a>00044 <span class="keyword">import</span> random
<a name="l00045"></a>00045 <span class="keyword">import</span> errno
<a name="l00046"></a>00046 <span class="keywordflow">try</span>:
<a name="l00047"></a>00047     <span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1 <span class="keyword">as</span> _sha, md5 <span class="keyword">as</span> _md5
<a name="l00048"></a>00048 <span class="keywordflow">except</span> ImportError:
<a name="l00049"></a>00049     <span class="comment"># prior to Python 2.5, these were separate modules</span>
<a name="l00050"></a>00050     <span class="keyword">import</span> sha
<a name="l00051"></a>00051     <span class="keyword">import</span> md5
<a name="l00052"></a>00052     _sha = sha.new
<a name="l00053"></a>00053     _md5 = md5.new
<a name="l00054"></a>00054 <span class="keyword">import</span> hmac
<a name="l00055"></a>00055 <span class="keyword">from</span> gettext <span class="keyword">import</span> gettext <span class="keyword">as</span> _
<a name="l00056"></a>00056 <span class="keyword">import</span> socket
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keywordflow">try</span>:
<a name="l00059"></a>00059     <span class="keyword">from</span> httplib2 <span class="keyword">import</span> socks
<a name="l00060"></a>00060 <span class="keywordflow">except</span> ImportError:
<a name="l00061"></a>00061     <span class="keywordflow">try</span>:
<a name="l00062"></a>00062         <span class="keyword">import</span> socks
<a name="l00063"></a>00063     <span class="keywordflow">except</span> ImportError:
<a name="l00064"></a>00064         socks = <span class="keywordtype">None</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment"># Build the appropriate socket wrapper for ssl</span>
<a name="l00067"></a>00067 <span class="keywordflow">try</span>:
<a name="l00068"></a>00068     <span class="keyword">import</span> ssl <span class="comment"># python 2.6</span>
<a name="l00069"></a>00069     ssl_SSLError = ssl.SSLError
<a name="l00070"></a>00070     <span class="keyword">def </span>_ssl_wrap_socket(sock, key_file, cert_file,
<a name="l00071"></a>00071                          disable_validation, ca_certs):
<a name="l00072"></a>00072         <span class="keywordflow">if</span> disable_validation:
<a name="l00073"></a>00073             cert_reqs = ssl.CERT_NONE
<a name="l00074"></a>00074         <span class="keywordflow">else</span>:
<a name="l00075"></a>00075             cert_reqs = ssl.CERT_REQUIRED
<a name="l00076"></a>00076         <span class="comment"># We should be specifying SSL version 3 or TLS v1, but the ssl module</span>
<a name="l00077"></a>00077         <span class="comment"># doesn&#39;t expose the necessary knobs. So we need to go with the default</span>
<a name="l00078"></a>00078         <span class="comment"># of SSLv23.</span>
<a name="l00079"></a>00079         <span class="keywordflow">return</span> ssl.wrap_socket(sock, keyfile=key_file, certfile=cert_file,
<a name="l00080"></a>00080                                cert_reqs=cert_reqs, ca_certs=ca_certs)
<a name="l00081"></a>00081 <span class="keywordflow">except</span> (AttributeError, ImportError):
<a name="l00082"></a>00082     ssl_SSLError = <span class="keywordtype">None</span>
<a name="l00083"></a>00083     <span class="keyword">def </span>_ssl_wrap_socket(sock, key_file, cert_file,
<a name="l00084"></a>00084                          disable_validation, ca_certs):
<a name="l00085"></a>00085         <span class="keywordflow">if</span> <span class="keywordflow">not</span> disable_validation:
<a name="l00086"></a>00086             <span class="keywordflow">raise</span> CertificateValidationUnsupported(
<a name="l00087"></a>00087                     <span class="stringliteral">&quot;SSL certificate validation is not supported without &quot;</span>
<a name="l00088"></a>00088                     <span class="stringliteral">&quot;the ssl module installed. To avoid this error, install &quot;</span>
<a name="l00089"></a>00089                     <span class="stringliteral">&quot;the ssl module, or explicity disable validation.&quot;</span>)
<a name="l00090"></a>00090         ssl_sock = socket.ssl(sock, key_file, cert_file)
<a name="l00091"></a>00091         <span class="keywordflow">return</span> httplib.FakeSocket(sock, ssl_sock)
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keywordflow">if</span> sys.version_info &gt;= (2,3):
<a name="l00095"></a>00095     <span class="keyword">from</span> iri2uri <span class="keyword">import</span> iri2uri
<a name="l00096"></a>00096 <span class="keywordflow">else</span>:
<a name="l00097"></a>00097     <span class="keyword">def </span>iri2uri(uri):
<a name="l00098"></a>00098         <span class="keywordflow">return</span> uri
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keyword">def </span>has_timeout(timeout): <span class="comment"># python 2.6</span>
<a name="l00101"></a>00101     <span class="keywordflow">if</span> hasattr(socket, <span class="stringliteral">&#39;_GLOBAL_DEFAULT_TIMEOUT&#39;</span>):
<a name="l00102"></a>00102         <span class="keywordflow">return</span> (timeout <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> timeout <span class="keywordflow">is</span> <span class="keywordflow">not</span> socket._GLOBAL_DEFAULT_TIMEOUT)
<a name="l00103"></a>00103     <span class="keywordflow">return</span> (timeout <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>)
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 __all__ = [<span class="stringliteral">&#39;Http&#39;</span>, <span class="stringliteral">&#39;Response&#39;</span>, <span class="stringliteral">&#39;ProxyInfo&#39;</span>, <span class="stringliteral">&#39;HttpLib2Error&#39;</span>,
<a name="l00106"></a>00106   <span class="stringliteral">&#39;RedirectMissingLocation&#39;</span>, <span class="stringliteral">&#39;RedirectLimit&#39;</span>, <span class="stringliteral">&#39;FailedToDecompressContent&#39;</span>,
<a name="l00107"></a>00107   <span class="stringliteral">&#39;UnimplementedDigestAuthOptionError&#39;</span>, <span class="stringliteral">&#39;UnimplementedHmacDigestAuthOptionError&#39;</span>,
<a name="l00108"></a>00108   <span class="stringliteral">&#39;debuglevel&#39;</span>, <span class="stringliteral">&#39;ProxiesUnavailableError&#39;</span>]
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment"># The httplib debug level, set to a non-zero value to get debug output</span>
<a name="l00112"></a>00112 debuglevel = 0
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment"># Python 2.3 support</span>
<a name="l00116"></a>00116 <span class="keywordflow">if</span> sys.version_info &lt; (2,4):
<a name="l00117"></a>00117     <span class="keyword">def </span>sorted(seq):
<a name="l00118"></a>00118         seq.sort()
<a name="l00119"></a>00119         <span class="keywordflow">return</span> seq
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment"># Python 2.3 support</span>
<a name="l00122"></a>00122 <span class="keyword">def </span>HTTPResponse__getheaders(self):
<a name="l00123"></a>00123     <span class="stringliteral">&quot;&quot;&quot;Return list of (header, value) tuples.&quot;&quot;&quot;</span>
<a name="l00124"></a>00124     <span class="keywordflow">if</span> self.msg <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00125"></a>00125         <span class="keywordflow">raise</span> httplib.ResponseNotReady()
<a name="l00126"></a>00126     <span class="keywordflow">return</span> self.msg.items()
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keywordflow">if</span> <span class="keywordflow">not</span> hasattr(httplib.HTTPResponse, <span class="stringliteral">&#39;getheaders&#39;</span>):
<a name="l00129"></a>00129     httplib.HTTPResponse.getheaders = HTTPResponse__getheaders
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment"># All exceptions raised here derive from HttpLib2Error</span>
<a name="l00132"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2Error.html">00132</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2Error.html">HttpLib2Error</a>(Exception): <span class="keywordflow">pass</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment"># Some exceptions can be caught and optionally</span>
<a name="l00135"></a>00135 <span class="comment"># be turned back into responses.</span>
<a name="l00136"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2ErrorWithResponse.html">00136</a> <span class="keyword">class</span> HttpLib2ErrorWithResponse(HttpLib2Error):
<a name="l00137"></a>00137     <span class="keyword">def </span>__init__(self, desc, response, content):
<a name="l00138"></a>00138         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2ErrorWithResponse.html#a4054f8c768f3572e74c080db1107f61f">response</a> = response
<a name="l00139"></a>00139         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2ErrorWithResponse.html#aa756301e49e41bd88700a132b689a332">content</a> = content
<a name="l00140"></a>00140         HttpLib2Error.__init__(self, desc)
<a name="l00141"></a>00141 
<a name="l00142"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1RedirectMissingLocation.html">00142</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1RedirectMissingLocation.html">RedirectMissingLocation</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2ErrorWithResponse.html">HttpLib2ErrorWithResponse</a>): <span class="keywordflow">pass</span>
<a name="l00143"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1RedirectLimit.html">00143</a> <span class="keyword">class</span> RedirectLimit(HttpLib2ErrorWithResponse): <span class="keywordflow">pass</span>
<a name="l00144"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FailedToDecompressContent.html">00144</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FailedToDecompressContent.html">FailedToDecompressContent</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2ErrorWithResponse.html">HttpLib2ErrorWithResponse</a>): <span class="keywordflow">pass</span>
<a name="l00145"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1UnimplementedDigestAuthOptionError.html">00145</a> <span class="keyword">class</span> UnimplementedDigestAuthOptionError(HttpLib2ErrorWithResponse): <span class="keywordflow">pass</span>
<a name="l00146"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1UnimplementedHmacDigestAuthOptionError.html">00146</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1UnimplementedHmacDigestAuthOptionError.html">UnimplementedHmacDigestAuthOptionError</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2ErrorWithResponse.html">HttpLib2ErrorWithResponse</a>): <span class="keywordflow">pass</span>
<a name="l00147"></a>00147 
<a name="l00148"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1MalformedHeader.html">00148</a> <span class="keyword">class</span> MalformedHeader(HttpLib2Error): <span class="keywordflow">pass</span>
<a name="l00149"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1RelativeURIError.html">00149</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1RelativeURIError.html">RelativeURIError</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2Error.html">HttpLib2Error</a>): <span class="keywordflow">pass</span>
<a name="l00150"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ServerNotFoundError.html">00150</a> <span class="keyword">class</span> ServerNotFoundError(HttpLib2Error): <span class="keywordflow">pass</span>
<a name="l00151"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxiesUnavailableError.html">00151</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxiesUnavailableError.html">ProxiesUnavailableError</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2Error.html">HttpLib2Error</a>): <span class="keywordflow">pass</span>
<a name="l00152"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1CertificateValidationUnsupported.html">00152</a> <span class="keyword">class</span> CertificateValidationUnsupported(HttpLib2Error): <span class="keywordflow">pass</span>
<a name="l00153"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1SSLHandshakeError.html">00153</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1SSLHandshakeError.html">SSLHandshakeError</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HttpLib2Error.html">HttpLib2Error</a>): <span class="keywordflow">pass</span>
<a name="l00154"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1NotSupportedOnThisPlatform.html">00154</a> <span class="keyword">class</span> NotSupportedOnThisPlatform(HttpLib2Error): <span class="keywordflow">pass</span>
<a name="l00155"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1CertificateHostnameMismatch.html">00155</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1CertificateHostnameMismatch.html">CertificateHostnameMismatch</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1SSLHandshakeError.html">SSLHandshakeError</a>):
<a name="l00156"></a>00156   <span class="keyword">def </span>__init__(self, desc, host, cert):
<a name="l00157"></a>00157     HttpLib2Error.__init__(self, desc)
<a name="l00158"></a>00158     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1CertificateHostnameMismatch.html#a439fff3d0185a03224f3e6a500569c92">host</a> = host
<a name="l00159"></a>00159     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1CertificateHostnameMismatch.html#a9fffee359fd6fe2801373ce9ccf31434">cert</a> = cert
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment"># Open Items:</span>
<a name="l00162"></a>00162 <span class="comment"># -----------</span>
<a name="l00163"></a>00163 <span class="comment"># Proxy support</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment"># Are we removing the cached content too soon on PUT (only delete on 200 Maybe?)</span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="comment"># Pluggable cache storage (supports storing the cache in</span>
<a name="l00168"></a>00168 <span class="comment">#   flat files by default. We need a plug-in architecture</span>
<a name="l00169"></a>00169 <span class="comment">#   that can support Berkeley DB and Squid)</span>
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment"># == Known Issues ==</span>
<a name="l00172"></a>00172 <span class="comment"># Does not handle a resource that uses conneg and Last-Modified but no ETag as a cache validator.</span>
<a name="l00173"></a>00173 <span class="comment"># Does not handle Cache-Control: max-stale</span>
<a name="l00174"></a>00174 <span class="comment"># Does not use Age: headers when calculating cache freshness.</span>
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment"># The number of redirections to follow before giving up.</span>
<a name="l00178"></a>00178 <span class="comment"># Note that only GET redirects are automatically followed.</span>
<a name="l00179"></a>00179 <span class="comment"># Will also honor 301 requests by saving that info and never</span>
<a name="l00180"></a>00180 <span class="comment"># requesting that URI again.</span>
<a name="l00181"></a>00181 DEFAULT_MAX_REDIRECTS = 5
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="comment"># Default CA certificates file bundled with httplib2.</span>
<a name="l00184"></a>00184 CA_CERTS = os.path.join(
<a name="l00185"></a>00185         os.path.dirname(os.path.abspath(__file__ )), <span class="stringliteral">&quot;cacerts.txt&quot;</span>)
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment"># Which headers are hop-by-hop headers by default</span>
<a name="l00188"></a>00188 HOP_BY_HOP = [<span class="stringliteral">&#39;connection&#39;</span>, <span class="stringliteral">&#39;keep-alive&#39;</span>, <span class="stringliteral">&#39;proxy-authenticate&#39;</span>, <span class="stringliteral">&#39;proxy-authorization&#39;</span>, <span class="stringliteral">&#39;te&#39;</span>, <span class="stringliteral">&#39;trailers&#39;</span>, <span class="stringliteral">&#39;transfer-encoding&#39;</span>, <span class="stringliteral">&#39;upgrade&#39;</span>]
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="keyword">def </span>_get_end2end_headers(response):
<a name="l00191"></a>00191     hopbyhop = list(HOP_BY_HOP)
<a name="l00192"></a>00192     hopbyhop.extend([x.strip() <span class="keywordflow">for</span> x <span class="keywordflow">in</span> response.get(<span class="stringliteral">&#39;connection&#39;</span>, <span class="stringliteral">&#39;&#39;</span>).split(<span class="stringliteral">&#39;,&#39;</span>)])
<a name="l00193"></a>00193     <span class="keywordflow">return</span> [header <span class="keywordflow">for</span> header <span class="keywordflow">in</span> response.keys() <span class="keywordflow">if</span> header <span class="keywordflow">not</span> <span class="keywordflow">in</span> hopbyhop]
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 URI = re.compile(<span class="stringliteral">r&quot;^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?&quot;</span>)
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keyword">def </span>parse_uri(uri):
<a name="l00198"></a>00198     <span class="stringliteral">&quot;&quot;&quot;Parses a URI using the regex given in Appendix B of RFC 3986.</span>
<a name="l00199"></a>00199 <span class="stringliteral"></span>
<a name="l00200"></a>00200 <span class="stringliteral">        (scheme, authority, path, query, fragment) = parse_uri(uri)</span>
<a name="l00201"></a>00201 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00202"></a>00202     groups = URI.match(uri).groups()
<a name="l00203"></a>00203     <span class="keywordflow">return</span> (groups[1], groups[3], groups[4], groups[6], groups[8])
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">def </span>urlnorm(uri):
<a name="l00206"></a>00206     (scheme, authority, path, query, fragment) = parse_uri(uri)
<a name="l00207"></a>00207     <span class="keywordflow">if</span> <span class="keywordflow">not</span> scheme <span class="keywordflow">or</span> <span class="keywordflow">not</span> authority:
<a name="l00208"></a>00208         <span class="keywordflow">raise</span> RelativeURIError(<span class="stringliteral">&quot;Only absolute URIs are allowed. uri = %s&quot;</span> % uri)
<a name="l00209"></a>00209     authority = authority.lower()
<a name="l00210"></a>00210     scheme = scheme.lower()
<a name="l00211"></a>00211     <span class="keywordflow">if</span> <span class="keywordflow">not</span> path:
<a name="l00212"></a>00212         path = <span class="stringliteral">&quot;/&quot;</span>
<a name="l00213"></a>00213     <span class="comment"># Could do syntax based normalization of the URI before</span>
<a name="l00214"></a>00214     <span class="comment"># computing the digest. See Section 6.2.2 of Std 66.</span>
<a name="l00215"></a>00215     request_uri = query <span class="keywordflow">and</span> <span class="stringliteral">&quot;?&quot;</span>.join([path, query]) <span class="keywordflow">or</span> path
<a name="l00216"></a>00216     scheme = scheme.lower()
<a name="l00217"></a>00217     defrag_uri = scheme + <span class="stringliteral">&quot;://&quot;</span> + authority + request_uri
<a name="l00218"></a>00218     <span class="keywordflow">return</span> scheme, authority, request_uri, defrag_uri
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="comment"># Cache filename construction (original borrowed from Venus http://intertwingly.net/code/venus/)</span>
<a name="l00222"></a>00222 re_url_scheme    = re.compile(<span class="stringliteral">r&#39;^\w+://&#39;</span>)
<a name="l00223"></a>00223 re_slash         = re.compile(<span class="stringliteral">r&#39;[?/:|]+&#39;</span>)
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">def </span>safename(filename):
<a name="l00226"></a>00226     <span class="stringliteral">&quot;&quot;&quot;Return a filename suitable for the cache.</span>
<a name="l00227"></a>00227 <span class="stringliteral"></span>
<a name="l00228"></a>00228 <span class="stringliteral">    Strips dangerous and common characters to create a filename we</span>
<a name="l00229"></a>00229 <span class="stringliteral">    can use to store the cache in.</span>
<a name="l00230"></a>00230 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     <span class="keywordflow">try</span>:
<a name="l00233"></a>00233         <span class="keywordflow">if</span> re_url_scheme.match(filename):
<a name="l00234"></a>00234             <span class="keywordflow">if</span> isinstance(filename,str):
<a name="l00235"></a>00235                 filename = filename.decode(<span class="stringliteral">&#39;utf-8&#39;</span>)
<a name="l00236"></a>00236                 filename = filename.encode(<span class="stringliteral">&#39;idna&#39;</span>)
<a name="l00237"></a>00237             <span class="keywordflow">else</span>:
<a name="l00238"></a>00238                 filename = filename.encode(<span class="stringliteral">&#39;idna&#39;</span>)
<a name="l00239"></a>00239     <span class="keywordflow">except</span> UnicodeError:
<a name="l00240"></a>00240         <span class="keywordflow">pass</span>
<a name="l00241"></a>00241     <span class="keywordflow">if</span> isinstance(filename,unicode):
<a name="l00242"></a>00242         filename=filename.encode(<span class="stringliteral">&#39;utf-8&#39;</span>)
<a name="l00243"></a>00243     filemd5 = _md5(filename).hexdigest()
<a name="l00244"></a>00244     filename = re_url_scheme.sub(<span class="stringliteral">&quot;&quot;</span>, filename)
<a name="l00245"></a>00245     filename = re_slash.sub(<span class="stringliteral">&quot;,&quot;</span>, filename)
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <span class="comment"># limit length of filename</span>
<a name="l00248"></a>00248     <span class="keywordflow">if</span> len(filename)&gt;200:
<a name="l00249"></a>00249         filename=filename[:200]
<a name="l00250"></a>00250     <span class="keywordflow">return</span> <span class="stringliteral">&quot;,&quot;</span>.join((filename, filemd5))
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 NORMALIZE_SPACE = re.compile(<span class="stringliteral">r&#39;(?:\r\n)?[ \t]+&#39;</span>)
<a name="l00253"></a>00253 <span class="keyword">def </span>_normalize_headers(headers):
<a name="l00254"></a>00254     <span class="keywordflow">return</span> dict([ (key.lower(), NORMALIZE_SPACE.sub(value, <span class="stringliteral">&#39; &#39;</span>).strip())  <span class="keywordflow">for</span> (key, value) <span class="keywordflow">in</span> headers.iteritems()])
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="keyword">def </span>_parse_cache_control(headers):
<a name="l00257"></a>00257     retval = {}
<a name="l00258"></a>00258     <span class="keywordflow">if</span> headers.has_key(<span class="stringliteral">&#39;cache-control&#39;</span>):
<a name="l00259"></a>00259         parts =  headers[<span class="stringliteral">&#39;cache-control&#39;</span>].split(<span class="stringliteral">&#39;,&#39;</span>)
<a name="l00260"></a>00260         parts_with_args = [tuple([x.strip().lower() <span class="keywordflow">for</span> x <span class="keywordflow">in</span> part.split(<span class="stringliteral">&quot;=&quot;</span>, 1)]) <span class="keywordflow">for</span> part <span class="keywordflow">in</span> parts <span class="keywordflow">if</span> -1 != part.find(<span class="stringliteral">&quot;=&quot;</span>)]
<a name="l00261"></a>00261         parts_wo_args = [(name.strip().lower(), 1) <span class="keywordflow">for</span> name <span class="keywordflow">in</span> parts <span class="keywordflow">if</span> -1 == name.find(<span class="stringliteral">&quot;=&quot;</span>)]
<a name="l00262"></a>00262         retval = dict(parts_with_args + parts_wo_args)
<a name="l00263"></a>00263     <span class="keywordflow">return</span> retval
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment"># Whether to use a strict mode to parse WWW-Authenticate headers</span>
<a name="l00266"></a>00266 <span class="comment"># Might lead to bad results in case of ill-formed header value,</span>
<a name="l00267"></a>00267 <span class="comment"># so disabled by default, falling back to relaxed parsing.</span>
<a name="l00268"></a>00268 <span class="comment"># Set to true to turn on, usefull for testing servers.</span>
<a name="l00269"></a>00269 USE_WWW_AUTH_STRICT_PARSING = 0
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment"># In regex below:</span>
<a name="l00272"></a>00272 <span class="comment">#    [^\0-\x1f\x7f-\xff()&lt;&gt;@,;:\\\&quot;/[\]?={} \t]+             matches a &quot;token&quot; as defined by HTTP</span>
<a name="l00273"></a>00273 <span class="comment">#    &quot;(?:[^\0-\x08\x0A-\x1f\x7f-\xff\\\&quot;]|\\[\0-\x7f])*?&quot;    matches a &quot;quoted-string&quot; as defined by HTTP, when LWS have already been replaced by a single space</span>
<a name="l00274"></a>00274 <span class="comment"># Actually, as an auth-param value can be either a token or a quoted-string, they are combined in a single pattern which matches both:</span>
<a name="l00275"></a>00275 <span class="comment">#    \&quot;?((?&lt;=\&quot;)(?:[^\0-\x1f\x7f-\xff\\\&quot;]|\\[\0-\x7f])*?(?=\&quot;)|(?&lt;!\&quot;)[^\0-\x08\x0A-\x1f\x7f-\xff()&lt;&gt;@,;:\\\&quot;/[\]?={} \t]+(?!\&quot;))\&quot;?</span>
<a name="l00276"></a>00276 WWW_AUTH_STRICT = re.compile(<span class="stringliteral">r&quot;^(?:\s*(?:,\s*)?([^\0-\x1f\x7f-\xff()&lt;&gt;@,;:\\\&quot;/[\]?={} \t]+)\s*=\s*\&quot;?((?&lt;=\&quot;)(?:[^\0-\x08\x0A-\x1f\x7f-\xff\\\&quot;]|\\[\0-\x7f])*?(?=\&quot;)|(?&lt;!\&quot;)[^\0-\x1f\x7f-\xff()&lt;&gt;@,;:\\\&quot;/[\]?={} \t]+(?!\&quot;))\&quot;?)(.*)$&quot;</span>)
<a name="l00277"></a>00277 WWW_AUTH_RELAXED = re.compile(<span class="stringliteral">r&quot;^(?:\s*(?:,\s*)?([^ \t\r\n=]+)\s*=\s*\&quot;?((?&lt;=\&quot;)(?:[^\\\&quot;]|\\.)*?(?=\&quot;)|(?&lt;!\&quot;)[^ \t\r\n,]+(?!\&quot;))\&quot;?)(.*)$&quot;</span>)
<a name="l00278"></a>00278 UNQUOTE_PAIRS = re.compile(<span class="stringliteral">r&#39;\\(.)&#39;</span>)
<a name="l00279"></a>00279 <span class="keyword">def </span>_parse_www_authenticate(headers, headername=&#39;www-authenticate&#39;):
<a name="l00280"></a>00280     <span class="stringliteral">&quot;&quot;&quot;Returns a dictionary of dictionaries, one dict</span>
<a name="l00281"></a>00281 <span class="stringliteral">    per auth_scheme.&quot;&quot;&quot;</span>
<a name="l00282"></a>00282     retval = {}
<a name="l00283"></a>00283     <span class="keywordflow">if</span> headers.has_key(headername):
<a name="l00284"></a>00284         <span class="keywordflow">try</span>:
<a name="l00285"></a>00285           authenticate = headers[headername].strip()
<a name="l00286"></a>00286           www_auth = USE_WWW_AUTH_STRICT_PARSING <span class="keywordflow">and</span> WWW_AUTH_STRICT <span class="keywordflow">or</span> WWW_AUTH_RELAXED
<a name="l00287"></a>00287           <span class="keywordflow">while</span> authenticate:
<a name="l00288"></a>00288               <span class="comment"># Break off the scheme at the beginning of the line</span>
<a name="l00289"></a>00289               <span class="keywordflow">if</span> headername == <span class="stringliteral">&#39;authentication-info&#39;</span>:
<a name="l00290"></a>00290                   (auth_scheme, the_rest) = (<span class="stringliteral">&#39;digest&#39;</span>, authenticate)
<a name="l00291"></a>00291               <span class="keywordflow">else</span>:
<a name="l00292"></a>00292                   (auth_scheme, the_rest) = authenticate.split(<span class="stringliteral">&quot; &quot;</span>, 1)
<a name="l00293"></a>00293               <span class="comment"># Now loop over all the key value pairs that come after the scheme,</span>
<a name="l00294"></a>00294               <span class="comment"># being careful not to roll into the next scheme</span>
<a name="l00295"></a>00295               match = www_auth.search(the_rest)
<a name="l00296"></a>00296               auth_params = {}
<a name="l00297"></a>00297               <span class="keywordflow">while</span> match:
<a name="l00298"></a>00298                   <span class="keywordflow">if</span> match <span class="keywordflow">and</span> len(match.groups()) == 3:
<a name="l00299"></a>00299                       (key, value, the_rest) = match.groups()
<a name="l00300"></a>00300                       auth_params[key.lower()] = UNQUOTE_PAIRS.sub(<span class="stringliteral">r&#39;\1&#39;</span>, value) <span class="comment"># &#39;\\&#39;.join([x.replace(&#39;\\&#39;, &#39;&#39;) for x in value.split(&#39;\\\\&#39;)])</span>
<a name="l00301"></a>00301                   match = www_auth.search(the_rest)
<a name="l00302"></a>00302               retval[auth_scheme.lower()] = auth_params
<a name="l00303"></a>00303               authenticate = the_rest.strip()
<a name="l00304"></a>00304         <span class="keywordflow">except</span> ValueError:
<a name="l00305"></a>00305           <span class="keywordflow">raise</span> MalformedHeader(<span class="stringliteral">&quot;WWW-Authenticate&quot;</span>)
<a name="l00306"></a>00306     <span class="keywordflow">return</span> retval
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="keyword">def </span>_entry_disposition(response_headers, request_headers):
<a name="l00310"></a>00310     <span class="stringliteral">&quot;&quot;&quot;Determine freshness from the Date, Expires and Cache-Control headers.</span>
<a name="l00311"></a>00311 <span class="stringliteral"></span>
<a name="l00312"></a>00312 <span class="stringliteral">    We don&#39;t handle the following:</span>
<a name="l00313"></a>00313 <span class="stringliteral"></span>
<a name="l00314"></a>00314 <span class="stringliteral">    1. Cache-Control: max-stale</span>
<a name="l00315"></a>00315 <span class="stringliteral">    2. Age: headers are not used in the calculations.</span>
<a name="l00316"></a>00316 <span class="stringliteral"></span>
<a name="l00317"></a>00317 <span class="stringliteral">    Not that this algorithm is simpler than you might think</span>
<a name="l00318"></a>00318 <span class="stringliteral">    because we are operating as a private (non-shared) cache.</span>
<a name="l00319"></a>00319 <span class="stringliteral">    This lets us ignore &#39;s-maxage&#39;. We can also ignore</span>
<a name="l00320"></a>00320 <span class="stringliteral">    &#39;proxy-invalidate&#39; since we aren&#39;t a proxy.</span>
<a name="l00321"></a>00321 <span class="stringliteral">    We will never return a stale document as</span>
<a name="l00322"></a>00322 <span class="stringliteral">    fresh as a design decision, and thus the non-implementation</span>
<a name="l00323"></a>00323 <span class="stringliteral">    of &#39;max-stale&#39;. This also lets us safely ignore &#39;must-revalidate&#39;</span>
<a name="l00324"></a>00324 <span class="stringliteral">    since we operate as if every server has sent &#39;must-revalidate&#39;.</span>
<a name="l00325"></a>00325 <span class="stringliteral">    Since we are private we get to ignore both &#39;public&#39; and</span>
<a name="l00326"></a>00326 <span class="stringliteral">    &#39;private&#39; parameters. We also ignore &#39;no-transform&#39; since</span>
<a name="l00327"></a>00327 <span class="stringliteral">    we don&#39;t do any transformations.</span>
<a name="l00328"></a>00328 <span class="stringliteral">    The &#39;no-store&#39; parameter is handled at a higher level.</span>
<a name="l00329"></a>00329 <span class="stringliteral">    So the only Cache-Control parameters we look at are:</span>
<a name="l00330"></a>00330 <span class="stringliteral"></span>
<a name="l00331"></a>00331 <span class="stringliteral">    no-cache</span>
<a name="l00332"></a>00332 <span class="stringliteral">    only-if-cached</span>
<a name="l00333"></a>00333 <span class="stringliteral">    max-age</span>
<a name="l00334"></a>00334 <span class="stringliteral">    min-fresh</span>
<a name="l00335"></a>00335 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     retval = <span class="stringliteral">&quot;STALE&quot;</span>
<a name="l00338"></a>00338     cc = _parse_cache_control(request_headers)
<a name="l00339"></a>00339     cc_response = _parse_cache_control(response_headers)
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     <span class="keywordflow">if</span> request_headers.has_key(<span class="stringliteral">&#39;pragma&#39;</span>) <span class="keywordflow">and</span> request_headers[<span class="stringliteral">&#39;pragma&#39;</span>].lower().find(<span class="stringliteral">&#39;no-cache&#39;</span>) != -1:
<a name="l00342"></a>00342         retval = <span class="stringliteral">&quot;TRANSPARENT&quot;</span>
<a name="l00343"></a>00343         <span class="keywordflow">if</span> <span class="stringliteral">&#39;cache-control&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> request_headers:
<a name="l00344"></a>00344             request_headers[<span class="stringliteral">&#39;cache-control&#39;</span>] = <span class="stringliteral">&#39;no-cache&#39;</span>
<a name="l00345"></a>00345     <span class="keywordflow">elif</span> cc.has_key(<span class="stringliteral">&#39;no-cache&#39;</span>):
<a name="l00346"></a>00346         retval = <span class="stringliteral">&quot;TRANSPARENT&quot;</span>
<a name="l00347"></a>00347     <span class="keywordflow">elif</span> cc_response.has_key(<span class="stringliteral">&#39;no-cache&#39;</span>):
<a name="l00348"></a>00348         retval = <span class="stringliteral">&quot;STALE&quot;</span>
<a name="l00349"></a>00349     <span class="keywordflow">elif</span> cc.has_key(<span class="stringliteral">&#39;only-if-cached&#39;</span>):
<a name="l00350"></a>00350         retval = <span class="stringliteral">&quot;FRESH&quot;</span>
<a name="l00351"></a>00351     <span class="keywordflow">elif</span> response_headers.has_key(<span class="stringliteral">&#39;date&#39;</span>):
<a name="l00352"></a>00352         date = calendar.timegm(email.Utils.parsedate_tz(response_headers[<span class="stringliteral">&#39;date&#39;</span>]))
<a name="l00353"></a>00353         now = time.time()
<a name="l00354"></a>00354         current_age = max(0, now - date)
<a name="l00355"></a>00355         <span class="keywordflow">if</span> cc_response.has_key(<span class="stringliteral">&#39;max-age&#39;</span>):
<a name="l00356"></a>00356             <span class="keywordflow">try</span>:
<a name="l00357"></a>00357                 freshness_lifetime = int(cc_response[<span class="stringliteral">&#39;max-age&#39;</span>])
<a name="l00358"></a>00358             <span class="keywordflow">except</span> ValueError:
<a name="l00359"></a>00359                 freshness_lifetime = 0
<a name="l00360"></a>00360         <span class="keywordflow">elif</span> response_headers.has_key(<span class="stringliteral">&#39;expires&#39;</span>):
<a name="l00361"></a>00361             expires = email.Utils.parsedate_tz(response_headers[<span class="stringliteral">&#39;expires&#39;</span>])
<a name="l00362"></a>00362             <span class="keywordflow">if</span> <span class="keywordtype">None</span> == expires:
<a name="l00363"></a>00363                 freshness_lifetime = 0
<a name="l00364"></a>00364             <span class="keywordflow">else</span>:
<a name="l00365"></a>00365                 freshness_lifetime = max(0, calendar.timegm(expires) - date)
<a name="l00366"></a>00366         <span class="keywordflow">else</span>:
<a name="l00367"></a>00367             freshness_lifetime = 0
<a name="l00368"></a>00368         <span class="keywordflow">if</span> cc.has_key(<span class="stringliteral">&#39;max-age&#39;</span>):
<a name="l00369"></a>00369             <span class="keywordflow">try</span>:
<a name="l00370"></a>00370                 freshness_lifetime = int(cc[<span class="stringliteral">&#39;max-age&#39;</span>])
<a name="l00371"></a>00371             <span class="keywordflow">except</span> ValueError:
<a name="l00372"></a>00372                 freshness_lifetime = 0
<a name="l00373"></a>00373         <span class="keywordflow">if</span> cc.has_key(<span class="stringliteral">&#39;min-fresh&#39;</span>):
<a name="l00374"></a>00374             <span class="keywordflow">try</span>:
<a name="l00375"></a>00375                 min_fresh = int(cc[<span class="stringliteral">&#39;min-fresh&#39;</span>])
<a name="l00376"></a>00376             <span class="keywordflow">except</span> ValueError:
<a name="l00377"></a>00377                 min_fresh = 0
<a name="l00378"></a>00378             current_age += min_fresh
<a name="l00379"></a>00379         <span class="keywordflow">if</span> freshness_lifetime &gt; current_age:
<a name="l00380"></a>00380             retval = <span class="stringliteral">&quot;FRESH&quot;</span>
<a name="l00381"></a>00381     <span class="keywordflow">return</span> retval
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="keyword">def </span>_decompressContent(response, new_content):
<a name="l00384"></a>00384     content = new_content
<a name="l00385"></a>00385     <span class="keywordflow">try</span>:
<a name="l00386"></a>00386         encoding = response.get(<span class="stringliteral">&#39;content-encoding&#39;</span>, <span class="keywordtype">None</span>)
<a name="l00387"></a>00387         <span class="keywordflow">if</span> encoding <span class="keywordflow">in</span> [<span class="stringliteral">&#39;gzip&#39;</span>, <span class="stringliteral">&#39;deflate&#39;</span>]:
<a name="l00388"></a>00388             <span class="keywordflow">if</span> encoding == <span class="stringliteral">&#39;gzip&#39;</span>:
<a name="l00389"></a>00389                 content = gzip.GzipFile(fileobj=StringIO.StringIO(new_content)).read()
<a name="l00390"></a>00390             <span class="keywordflow">if</span> encoding == <span class="stringliteral">&#39;deflate&#39;</span>:
<a name="l00391"></a>00391                 content = zlib.decompress(content)
<a name="l00392"></a>00392             response[<span class="stringliteral">&#39;content-length&#39;</span>] = str(len(content))
<a name="l00393"></a>00393             <span class="comment"># Record the historical presence of the encoding in a way the won&#39;t interfere.</span>
<a name="l00394"></a>00394             response[<span class="stringliteral">&#39;-content-encoding&#39;</span>] = response[<span class="stringliteral">&#39;content-encoding&#39;</span>]
<a name="l00395"></a>00395             del response[<span class="stringliteral">&#39;content-encoding&#39;</span>]
<a name="l00396"></a>00396     <span class="keywordflow">except</span> IOError:
<a name="l00397"></a>00397         content = <span class="stringliteral">&quot;&quot;</span>
<a name="l00398"></a>00398         <span class="keywordflow">raise</span> FailedToDecompressContent(_(<span class="stringliteral">&quot;Content purported to be compressed with %s but failed to decompress.&quot;</span>) % response.get(<span class="stringliteral">&#39;content-encoding&#39;</span>), response, content)
<a name="l00399"></a>00399     <span class="keywordflow">return</span> content
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="keyword">def </span>_updateCache(request_headers, response_headers, content, cache, cachekey):
<a name="l00402"></a>00402     <span class="keywordflow">if</span> cachekey:
<a name="l00403"></a>00403         cc = _parse_cache_control(request_headers)
<a name="l00404"></a>00404         cc_response = _parse_cache_control(response_headers)
<a name="l00405"></a>00405         <span class="keywordflow">if</span> cc.has_key(<span class="stringliteral">&#39;no-store&#39;</span>) <span class="keywordflow">or</span> cc_response.has_key(<span class="stringliteral">&#39;no-store&#39;</span>):
<a name="l00406"></a>00406             cache.delete(cachekey)
<a name="l00407"></a>00407         <span class="keywordflow">else</span>:
<a name="l00408"></a>00408             info = email.Message.Message()
<a name="l00409"></a>00409             <span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> response_headers.iteritems():
<a name="l00410"></a>00410                 <span class="keywordflow">if</span> key <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;status&#39;</span>,<span class="stringliteral">&#39;content-encoding&#39;</span>,<span class="stringliteral">&#39;transfer-encoding&#39;</span>]:
<a name="l00411"></a>00411                     info[key] = value
<a name="l00412"></a>00412 
<a name="l00413"></a>00413             <span class="comment"># Add annotations to the cache to indicate what headers</span>
<a name="l00414"></a>00414             <span class="comment"># are variant for this request.</span>
<a name="l00415"></a>00415             vary = response_headers.get(<span class="stringliteral">&#39;vary&#39;</span>, <span class="keywordtype">None</span>)
<a name="l00416"></a>00416             <span class="keywordflow">if</span> vary:
<a name="l00417"></a>00417                 vary_headers = vary.lower().replace(<span class="stringliteral">&#39; &#39;</span>, <span class="stringliteral">&#39;&#39;</span>).split(<span class="stringliteral">&#39;,&#39;</span>)
<a name="l00418"></a>00418                 <span class="keywordflow">for</span> header <span class="keywordflow">in</span> vary_headers:
<a name="l00419"></a>00419                     key = <span class="stringliteral">&#39;-varied-%s&#39;</span> % header
<a name="l00420"></a>00420                     <span class="keywordflow">try</span>:
<a name="l00421"></a>00421                         info[key] = request_headers[header]
<a name="l00422"></a>00422                     <span class="keywordflow">except</span> KeyError:
<a name="l00423"></a>00423                         <span class="keywordflow">pass</span>
<a name="l00424"></a>00424 
<a name="l00425"></a>00425             status = response_headers.status
<a name="l00426"></a>00426             <span class="keywordflow">if</span> status == 304:
<a name="l00427"></a>00427                 status = 200
<a name="l00428"></a>00428 
<a name="l00429"></a>00429             status_header = <span class="stringliteral">&#39;status: %d\r\n&#39;</span> % status
<a name="l00430"></a>00430 
<a name="l00431"></a>00431             header_str = info.as_string()
<a name="l00432"></a>00432 
<a name="l00433"></a>00433             header_str = re.sub(<span class="stringliteral">&quot;\r(?!\n)|(?&lt;!\r)\n&quot;</span>, <span class="stringliteral">&quot;\r\n&quot;</span>, header_str)
<a name="l00434"></a>00434             text = <span class="stringliteral">&quot;&quot;</span>.join([status_header, header_str, content])
<a name="l00435"></a>00435 
<a name="l00436"></a>00436             cache.set(cachekey, text)
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="keyword">def </span>_cnonce():
<a name="l00439"></a>00439     dig = _md5(<span class="stringliteral">&quot;%s:%s&quot;</span> % (time.ctime(), [<span class="stringliteral">&quot;0123456789&quot;</span>[random.randrange(0, 9)] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(20)])).hexdigest()
<a name="l00440"></a>00440     <span class="keywordflow">return</span> dig[:16]
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="keyword">def </span>_wsse_username_token(cnonce, iso_now, password):
<a name="l00443"></a>00443     <span class="keywordflow">return</span> base64.b64encode(_sha(<span class="stringliteral">&quot;%s%s%s&quot;</span> % (cnonce, iso_now, password)).digest()).strip()
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="comment"># For credentials we need two things, first</span>
<a name="l00447"></a>00447 <span class="comment"># a pool of credential to try (not necesarily tied to BAsic, Digest, etc.)</span>
<a name="l00448"></a>00448 <span class="comment"># Then we also need a list of URIs that have already demanded authentication</span>
<a name="l00449"></a>00449 <span class="comment"># That list is tricky since sub-URIs can take the same auth, or the</span>
<a name="l00450"></a>00450 <span class="comment"># auth scheme may change as you descend the tree.</span>
<a name="l00451"></a>00451 <span class="comment"># So we also need each Auth instance to be able to tell us</span>
<a name="l00452"></a>00452 <span class="comment"># how close to the &#39;top&#39; it is.</span>
<a name="l00453"></a>00453 
<a name="l00454"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">00454</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">Authentication</a>(object):
<a name="l00455"></a>00455     <span class="keyword">def </span>__init__(self, credentials, host, request_uri, headers, response, content, http):
<a name="l00456"></a>00456         (scheme, authority, path, query, fragment) = parse_uri(request_uri)
<a name="l00457"></a>00457         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#aa95048aabf40d7420ecf89ec2f2ae1b0">path</a> = path
<a name="l00458"></a>00458         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#a16468b48382b1dba4783b777c95dce0a">host</a> = host
<a name="l00459"></a>00459         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#a0a65cae71abc562c6d03028e60e31f7b">credentials</a> = credentials
<a name="l00460"></a>00460         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#ab5f60a823a2949386caf3a753ad97b39">http</a> = http
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keyword">def </span>depth(self, request_uri):
<a name="l00463"></a>00463         (scheme, authority, path, query, fragment) = parse_uri(request_uri)
<a name="l00464"></a>00464         <span class="keywordflow">return</span> request_uri[len(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#aa95048aabf40d7420ecf89ec2f2ae1b0">path</a>):].count(<span class="stringliteral">&quot;/&quot;</span>)
<a name="l00465"></a>00465 
<a name="l00466"></a>00466     <span class="keyword">def </span>inscope(self, host, request_uri):
<a name="l00467"></a>00467         <span class="comment"># XXX Should we normalize the request_uri?</span>
<a name="l00468"></a>00468         (scheme, authority, path, query, fragment) = parse_uri(request_uri)
<a name="l00469"></a>00469         <span class="keywordflow">return</span> (host == self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#a16468b48382b1dba4783b777c95dce0a">host</a>) <span class="keywordflow">and</span> path.startswith(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#aa95048aabf40d7420ecf89ec2f2ae1b0">path</a>)
<a name="l00470"></a>00470 
<a name="l00471"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#ac006272cfdabf31bb3a34787e43b8693">00471</a>     <span class="keyword">def </span>request(self, method, request_uri, headers, content):
<a name="l00472"></a>00472         <span class="stringliteral">&quot;&quot;&quot;Modify the request headers to add the appropriate</span>
<a name="l00473"></a>00473 <span class="stringliteral">        Authorization header. Over-rise this in sub-classes.&quot;&quot;&quot;</span>
<a name="l00474"></a>00474         <span class="keywordflow">pass</span>
<a name="l00475"></a>00475 
<a name="l00476"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html#a5776c48d4d74e81f72727085efa6d4fe">00476</a>     <span class="keyword">def </span>response(self, response, content):
<a name="l00477"></a>00477         <span class="stringliteral">&quot;&quot;&quot;Gives us a chance to update with new nonces</span>
<a name="l00478"></a>00478 <span class="stringliteral">        or such returned from the last authorized response.</span>
<a name="l00479"></a>00479 <span class="stringliteral">        Over-rise this in sub-classes if necessary.</span>
<a name="l00480"></a>00480 <span class="stringliteral"></span>
<a name="l00481"></a>00481 <span class="stringliteral">        Return TRUE is the request is to be retried, for</span>
<a name="l00482"></a>00482 <span class="stringliteral">        example Digest may return stale=true.</span>
<a name="l00483"></a>00483 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00484"></a>00484         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 
<a name="l00488"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1BasicAuthentication.html">00488</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1BasicAuthentication.html">BasicAuthentication</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">Authentication</a>):
<a name="l00489"></a>00489     <span class="keyword">def </span>__init__(self, credentials, host, request_uri, headers, response, content, http):
<a name="l00490"></a>00490         Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)
<a name="l00491"></a>00491 
<a name="l00492"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1BasicAuthentication.html#a111076e4083fa62981cd864e465efe92">00492</a>     <span class="keyword">def </span>request(self, method, request_uri, headers, content):
<a name="l00493"></a>00493         <span class="stringliteral">&quot;&quot;&quot;Modify the request headers to add the appropriate</span>
<a name="l00494"></a>00494 <span class="stringliteral">        Authorization header.&quot;&quot;&quot;</span>
<a name="l00495"></a>00495         headers[<span class="stringliteral">&#39;authorization&#39;</span>] = <span class="stringliteral">&#39;Basic &#39;</span> + base64.b64encode(<span class="stringliteral">&quot;%s:%s&quot;</span> % self.credentials).strip()
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 
<a name="l00498"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html">00498</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html">DigestAuthentication</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">Authentication</a>):
<a name="l00499"></a>00499     <span class="stringliteral">&quot;&quot;&quot;Only do qop=&#39;auth&#39; and MD5, since that</span>
<a name="l00500"></a>00500 <span class="stringliteral">    is all Apache currently implements&quot;&quot;&quot;</span>
<a name="l00501"></a>00501     <span class="keyword">def </span>__init__(self, credentials, host, request_uri, headers, response, content, http):
<a name="l00502"></a>00502         Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)
<a name="l00503"></a>00503         challenge = _parse_www_authenticate(response, <span class="stringliteral">&#39;www-authenticate&#39;</span>)
<a name="l00504"></a>00504         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a> = challenge[<span class="stringliteral">&#39;digest&#39;</span>]
<a name="l00505"></a>00505         qop = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>.get(<span class="stringliteral">&#39;qop&#39;</span>, <span class="stringliteral">&#39;auth&#39;</span>)
<a name="l00506"></a>00506         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;qop&#39;</span>] = (<span class="stringliteral">&#39;auth&#39;</span> <span class="keywordflow">in</span> [x.strip() <span class="keywordflow">for</span> x <span class="keywordflow">in</span> qop.split()]) <span class="keywordflow">and</span> <span class="stringliteral">&#39;auth&#39;</span> <span class="keywordflow">or</span> <span class="keywordtype">None</span>
<a name="l00507"></a>00507         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;qop&#39;</span>] <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00508"></a>00508             <span class="keywordflow">raise</span> UnimplementedDigestAuthOptionError( _(<span class="stringliteral">&quot;Unsupported value for qop: %s.&quot;</span> % qop))
<a name="l00509"></a>00509         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>] = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>.get(<span class="stringliteral">&#39;algorithm&#39;</span>, <span class="stringliteral">&#39;MD5&#39;</span>).upper()
<a name="l00510"></a>00510         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>] != <span class="stringliteral">&#39;MD5&#39;</span>:
<a name="l00511"></a>00511             <span class="keywordflow">raise</span> UnimplementedDigestAuthOptionError( _(<span class="stringliteral">&quot;Unsupported value for algorithm: %s.&quot;</span> % self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>]))
<a name="l00512"></a>00512         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad62ac0b07e94985d82b29f83b5f67940">A1</a> = <span class="stringliteral">&quot;&quot;</span>.join([self.credentials[0], <span class="stringliteral">&quot;:&quot;</span>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;realm&#39;</span>], <span class="stringliteral">&quot;:&quot;</span>, self.credentials[1]])
<a name="l00513"></a>00513         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nc&#39;</span>] = 1
<a name="l00514"></a>00514 
<a name="l00515"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#a7c5d94d8c2aea850d2f29e72e18c14de">00515</a>     <span class="keyword">def </span>request(self, method, request_uri, headers, content, cnonce = None):
<a name="l00516"></a>00516         <span class="stringliteral">&quot;&quot;&quot;Modify the request headers&quot;&quot;&quot;</span>
<a name="l00517"></a>00517         H = <span class="keyword">lambda</span> x: _md5(x).hexdigest()
<a name="l00518"></a>00518         KD = <span class="keyword">lambda</span> s, d: H(<span class="stringliteral">&quot;%s:%s&quot;</span> % (s, d))
<a name="l00519"></a>00519         A2 = <span class="stringliteral">&quot;&quot;</span>.join([method, <span class="stringliteral">&quot;:&quot;</span>, request_uri])
<a name="l00520"></a>00520         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;cnonce&#39;</span>] = cnonce <span class="keywordflow">or</span> _cnonce()
<a name="l00521"></a>00521         request_digest  = <span class="stringliteral">&#39;&quot;%s&quot;&#39;</span> % KD(H(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad62ac0b07e94985d82b29f83b5f67940">A1</a>), <span class="stringliteral">&quot;%s:%s:%s:%s:%s&quot;</span> % (self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nonce&#39;</span>],
<a name="l00522"></a>00522                     <span class="stringliteral">&#39;%08x&#39;</span> % self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nc&#39;</span>],
<a name="l00523"></a>00523                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;cnonce&#39;</span>],
<a name="l00524"></a>00524                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;qop&#39;</span>], H(A2)
<a name="l00525"></a>00525                     ))
<a name="l00526"></a>00526         headers[<span class="stringliteral">&#39;authorization&#39;</span>] = <span class="stringliteral">&#39;Digest username=&quot;%s&quot;, realm=&quot;%s&quot;, nonce=&quot;%s&quot;, uri=&quot;%s&quot;, algorithm=%s, response=%s, qop=%s, nc=%08x, cnonce=&quot;%s&quot;&#39;</span> % (
<a name="l00527"></a>00527                 self.credentials[0],
<a name="l00528"></a>00528                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;realm&#39;</span>],
<a name="l00529"></a>00529                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nonce&#39;</span>],
<a name="l00530"></a>00530                 request_uri,
<a name="l00531"></a>00531                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>],
<a name="l00532"></a>00532                 request_digest,
<a name="l00533"></a>00533                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;qop&#39;</span>],
<a name="l00534"></a>00534                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nc&#39;</span>],
<a name="l00535"></a>00535                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;cnonce&#39;</span>],
<a name="l00536"></a>00536                 )
<a name="l00537"></a>00537         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>.get(<span class="stringliteral">&#39;opaque&#39;</span>):
<a name="l00538"></a>00538             headers[<span class="stringliteral">&#39;authorization&#39;</span>] += <span class="stringliteral">&#39;, opaque=&quot;%s&quot;&#39;</span> % self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;opaque&#39;</span>]
<a name="l00539"></a>00539         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nc&#39;</span>] += 1
<a name="l00540"></a>00540 
<a name="l00541"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ac78eb8c728e0ca426f62bdd2ab76c699">00541</a>     <span class="keyword">def </span>response(self, response, content):
<a name="l00542"></a>00542         <span class="keywordflow">if</span> <span class="keywordflow">not</span> response.has_key(<span class="stringliteral">&#39;authentication-info&#39;</span>):
<a name="l00543"></a>00543             challenge = _parse_www_authenticate(response, <span class="stringliteral">&#39;www-authenticate&#39;</span>).get(<span class="stringliteral">&#39;digest&#39;</span>, {})
<a name="l00544"></a>00544             <span class="keywordflow">if</span> <span class="stringliteral">&#39;true&#39;</span> == challenge.get(<span class="stringliteral">&#39;stale&#39;</span>):
<a name="l00545"></a>00545                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nonce&#39;</span>] = challenge[<span class="stringliteral">&#39;nonce&#39;</span>]
<a name="l00546"></a>00546                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nc&#39;</span>] = 1
<a name="l00547"></a>00547                 <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l00548"></a>00548         <span class="keywordflow">else</span>:
<a name="l00549"></a>00549             updated_challenge = _parse_www_authenticate(response, <span class="stringliteral">&#39;authentication-info&#39;</span>).get(<span class="stringliteral">&#39;digest&#39;</span>, {})
<a name="l00550"></a>00550 
<a name="l00551"></a>00551             <span class="keywordflow">if</span> updated_challenge.has_key(<span class="stringliteral">&#39;nextnonce&#39;</span>):
<a name="l00552"></a>00552                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nonce&#39;</span>] = updated_challenge[<span class="stringliteral">&#39;nextnonce&#39;</span>]
<a name="l00553"></a>00553                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1DigestAuthentication.html#ad96cc0acce368b29ce7148b9cb248389">challenge</a>[<span class="stringliteral">&#39;nc&#39;</span>] = 1
<a name="l00554"></a>00554         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00557"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html">00557</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html">HmacDigestAuthentication</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">Authentication</a>):
<a name="l00558"></a>00558     <span class="stringliteral">&quot;&quot;&quot;Adapted from Robert Sayre&#39;s code and DigestAuthentication above.&quot;&quot;&quot;</span>
<a name="l00559"></a>00559     __author__ = <span class="stringliteral">&quot;Thomas Broyer (t.broyer@ltgt.net)&quot;</span>
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keyword">def </span>__init__(self, credentials, host, request_uri, headers, response, content, http):
<a name="l00562"></a>00562         Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)
<a name="l00563"></a>00563         challenge = _parse_www_authenticate(response, <span class="stringliteral">&#39;www-authenticate&#39;</span>)
<a name="l00564"></a>00564         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a> = challenge[<span class="stringliteral">&#39;hmacdigest&#39;</span>]
<a name="l00565"></a>00565         <span class="comment"># TODO: self.challenge[&#39;domain&#39;]</span>
<a name="l00566"></a>00566         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;reason&#39;</span>] = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>.get(<span class="stringliteral">&#39;reason&#39;</span>, <span class="stringliteral">&#39;unauthorized&#39;</span>)
<a name="l00567"></a>00567         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;reason&#39;</span>] <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;unauthorized&#39;</span>, <span class="stringliteral">&#39;integrity&#39;</span>]:
<a name="l00568"></a>00568             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;reason&#39;</span>] = <span class="stringliteral">&#39;unauthorized&#39;</span>
<a name="l00569"></a>00569         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;salt&#39;</span>] = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>.get(<span class="stringliteral">&#39;salt&#39;</span>, <span class="stringliteral">&#39;&#39;</span>)
<a name="l00570"></a>00570         <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>.get(<span class="stringliteral">&#39;snonce&#39;</span>):
<a name="l00571"></a>00571             <span class="keywordflow">raise</span> UnimplementedHmacDigestAuthOptionError( _(<span class="stringliteral">&quot;The challenge doesn&#39;t contain a server nonce, or this one is empty.&quot;</span>))
<a name="l00572"></a>00572         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>] = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>.get(<span class="stringliteral">&#39;algorithm&#39;</span>, <span class="stringliteral">&#39;HMAC-SHA-1&#39;</span>)
<a name="l00573"></a>00573         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>] <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;HMAC-SHA-1&#39;</span>, <span class="stringliteral">&#39;HMAC-MD5&#39;</span>]:
<a name="l00574"></a>00574             <span class="keywordflow">raise</span> UnimplementedHmacDigestAuthOptionError( _(<span class="stringliteral">&quot;Unsupported value for algorithm: %s.&quot;</span> % self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>]))
<a name="l00575"></a>00575         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;pw-algorithm&#39;</span>] = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>.get(<span class="stringliteral">&#39;pw-algorithm&#39;</span>, <span class="stringliteral">&#39;SHA-1&#39;</span>)
<a name="l00576"></a>00576         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;pw-algorithm&#39;</span>] <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;SHA-1&#39;</span>, <span class="stringliteral">&#39;MD5&#39;</span>]:
<a name="l00577"></a>00577             <span class="keywordflow">raise</span> UnimplementedHmacDigestAuthOptionError( _(<span class="stringliteral">&quot;Unsupported value for pw-algorithm: %s.&quot;</span> % self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;pw-algorithm&#39;</span>]))
<a name="l00578"></a>00578         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;algorithm&#39;</span>] == <span class="stringliteral">&#39;HMAC-MD5&#39;</span>:
<a name="l00579"></a>00579             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#ab6758d640cf019806856221ec3bfa642">hashmod</a> = _md5
<a name="l00580"></a>00580         <span class="keywordflow">else</span>:
<a name="l00581"></a>00581             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#ab6758d640cf019806856221ec3bfa642">hashmod</a> = _sha
<a name="l00582"></a>00582         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;pw-algorithm&#39;</span>] == <span class="stringliteral">&#39;MD5&#39;</span>:
<a name="l00583"></a>00583             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#aa12c2fade692568160d79bdedd7b7f71">pwhashmod</a> = _md5
<a name="l00584"></a>00584         <span class="keywordflow">else</span>:
<a name="l00585"></a>00585             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#aa12c2fade692568160d79bdedd7b7f71">pwhashmod</a> = _sha
<a name="l00586"></a>00586         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a287787cdda48e06a170716b22c9396ea">key</a> = <span class="stringliteral">&quot;&quot;</span>.join([self.credentials[0], <span class="stringliteral">&quot;:&quot;</span>,
<a name="l00587"></a>00587                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#aa12c2fade692568160d79bdedd7b7f71">pwhashmod</a>.new(<span class="stringliteral">&quot;&quot;</span>.join([self.credentials[1], self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;salt&#39;</span>]])).hexdigest().lower(),
<a name="l00588"></a>00588                     <span class="stringliteral">&quot;:&quot;</span>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;realm&#39;</span>]
<a name="l00589"></a>00589                     ])
<a name="l00590"></a>00590         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a287787cdda48e06a170716b22c9396ea">key</a> = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#aa12c2fade692568160d79bdedd7b7f71">pwhashmod</a>.new(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a287787cdda48e06a170716b22c9396ea">key</a>).hexdigest().lower()
<a name="l00591"></a>00591 
<a name="l00592"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#ac32c0de4914ac708ec89d1355ab6f311">00592</a>     <span class="keyword">def </span>request(self, method, request_uri, headers, content):
<a name="l00593"></a>00593         <span class="stringliteral">&quot;&quot;&quot;Modify the request headers&quot;&quot;&quot;</span>
<a name="l00594"></a>00594         keys = _get_end2end_headers(headers)
<a name="l00595"></a>00595         keylist = <span class="stringliteral">&quot;&quot;</span>.join([<span class="stringliteral">&quot;%s &quot;</span> % k <span class="keywordflow">for</span> k <span class="keywordflow">in</span> keys])
<a name="l00596"></a>00596         headers_val = <span class="stringliteral">&quot;&quot;</span>.join([headers[k] <span class="keywordflow">for</span> k <span class="keywordflow">in</span> keys])
<a name="l00597"></a>00597         created = time.strftime(<span class="stringliteral">&#39;%Y-%m-%dT%H:%M:%SZ&#39;</span>,time.gmtime())
<a name="l00598"></a>00598         cnonce = _cnonce()
<a name="l00599"></a>00599         request_digest = <span class="stringliteral">&quot;%s:%s:%s:%s:%s&quot;</span> % (method, request_uri, cnonce, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;snonce&#39;</span>], headers_val)
<a name="l00600"></a>00600         request_digest  = hmac.new(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a287787cdda48e06a170716b22c9396ea">key</a>, request_digest, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#ab6758d640cf019806856221ec3bfa642">hashmod</a>).hexdigest().lower()
<a name="l00601"></a>00601         headers[<span class="stringliteral">&#39;authorization&#39;</span>] = <span class="stringliteral">&#39;HMACDigest username=&quot;%s&quot;, realm=&quot;%s&quot;, snonce=&quot;%s&quot;, cnonce=&quot;%s&quot;, uri=&quot;%s&quot;, created=&quot;%s&quot;, response=&quot;%s&quot;, headers=&quot;%s&quot;&#39;</span> % (
<a name="l00602"></a>00602                 self.credentials[0],
<a name="l00603"></a>00603                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;realm&#39;</span>],
<a name="l00604"></a>00604                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a3eade7a011550b6561ffef99ed26d1ed">challenge</a>[<span class="stringliteral">&#39;snonce&#39;</span>],
<a name="l00605"></a>00605                 cnonce,
<a name="l00606"></a>00606                 request_uri,
<a name="l00607"></a>00607                 created,
<a name="l00608"></a>00608                 request_digest,
<a name="l00609"></a>00609                 keylist,
<a name="l00610"></a>00610                 )
<a name="l00611"></a>00611 
<a name="l00612"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HmacDigestAuthentication.html#a040fe3be76ee87f6e9d2a7ac990ebe7f">00612</a>     <span class="keyword">def </span>response(self, response, content):
<a name="l00613"></a>00613         challenge = _parse_www_authenticate(response, <span class="stringliteral">&#39;www-authenticate&#39;</span>).get(<span class="stringliteral">&#39;hmacdigest&#39;</span>, {})
<a name="l00614"></a>00614         <span class="keywordflow">if</span> challenge.get(<span class="stringliteral">&#39;reason&#39;</span>) <span class="keywordflow">in</span> [<span class="stringliteral">&#39;integrity&#39;</span>, <span class="stringliteral">&#39;stale&#39;</span>]:
<a name="l00615"></a>00615             <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l00616"></a>00616         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 
<a name="l00619"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1WsseAuthentication.html">00619</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1WsseAuthentication.html">WsseAuthentication</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">Authentication</a>):
<a name="l00620"></a>00620     <span class="stringliteral">&quot;&quot;&quot;This is thinly tested and should not be relied upon.</span>
<a name="l00621"></a>00621 <span class="stringliteral">    At this time there isn&#39;t any third party server to test against.</span>
<a name="l00622"></a>00622 <span class="stringliteral">    Blogger and TypePad implemented this algorithm at one point</span>
<a name="l00623"></a>00623 <span class="stringliteral">    but Blogger has since switched to Basic over HTTPS and</span>
<a name="l00624"></a>00624 <span class="stringliteral">    TypePad has implemented it wrong, by never issuing a 401</span>
<a name="l00625"></a>00625 <span class="stringliteral">    challenge but instead requiring your client to telepathically know that</span>
<a name="l00626"></a>00626 <span class="stringliteral">    their endpoint is expecting WSSE profile=&quot;UsernameToken&quot;.&quot;&quot;&quot;</span>
<a name="l00627"></a>00627     <span class="keyword">def </span>__init__(self, credentials, host, request_uri, headers, response, content, http):
<a name="l00628"></a>00628         Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)
<a name="l00629"></a>00629 
<a name="l00630"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1WsseAuthentication.html#acf5f9a36232a8065ffb6425cf51eb379">00630</a>     <span class="keyword">def </span>request(self, method, request_uri, headers, content):
<a name="l00631"></a>00631         <span class="stringliteral">&quot;&quot;&quot;Modify the request headers to add the appropriate</span>
<a name="l00632"></a>00632 <span class="stringliteral">        Authorization header.&quot;&quot;&quot;</span>
<a name="l00633"></a>00633         headers[<span class="stringliteral">&#39;authorization&#39;</span>] = <span class="stringliteral">&#39;WSSE profile=&quot;UsernameToken&quot;&#39;</span>
<a name="l00634"></a>00634         iso_now = time.strftime(<span class="stringliteral">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span>, time.gmtime())
<a name="l00635"></a>00635         cnonce = _cnonce()
<a name="l00636"></a>00636         password_digest = _wsse_username_token(cnonce, iso_now, self.credentials[1])
<a name="l00637"></a>00637         headers[<span class="stringliteral">&#39;X-WSSE&#39;</span>] = <span class="stringliteral">&#39;UsernameToken Username=&quot;%s&quot;, PasswordDigest=&quot;%s&quot;, Nonce=&quot;%s&quot;, Created=&quot;%s&quot;&#39;</span> % (
<a name="l00638"></a>00638                 self.credentials[0],
<a name="l00639"></a>00639                 password_digest,
<a name="l00640"></a>00640                 cnonce,
<a name="l00641"></a>00641                 iso_now)
<a name="l00642"></a>00642 
<a name="l00643"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1GoogleLoginAuthentication.html">00643</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1GoogleLoginAuthentication.html">GoogleLoginAuthentication</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Authentication.html">Authentication</a>):
<a name="l00644"></a>00644     <span class="keyword">def </span>__init__(self, credentials, host, request_uri, headers, response, content, http):
<a name="l00645"></a>00645         <span class="keyword">from</span> urllib <span class="keyword">import</span> urlencode
<a name="l00646"></a>00646         Authentication.__init__(self, credentials, host, request_uri, headers, response, content, http)
<a name="l00647"></a>00647         challenge = _parse_www_authenticate(response, <span class="stringliteral">&#39;www-authenticate&#39;</span>)
<a name="l00648"></a>00648         service = challenge[<span class="stringliteral">&#39;googlelogin&#39;</span>].get(<span class="stringliteral">&#39;service&#39;</span>, <span class="stringliteral">&#39;xapi&#39;</span>)
<a name="l00649"></a>00649         <span class="comment"># Bloggger actually returns the service in the challenge</span>
<a name="l00650"></a>00650         <span class="comment"># For the rest we guess based on the URI</span>
<a name="l00651"></a>00651         <span class="keywordflow">if</span> service == <span class="stringliteral">&#39;xapi&#39;</span> <span class="keywordflow">and</span>  request_uri.find(<span class="stringliteral">&quot;calendar&quot;</span>) &gt; 0:
<a name="l00652"></a>00652             service = <span class="stringliteral">&quot;cl&quot;</span>
<a name="l00653"></a>00653         <span class="comment"># No point in guessing Base or Spreadsheet</span>
<a name="l00654"></a>00654         <span class="comment">#elif request_uri.find(&quot;spreadsheets&quot;) &gt; 0:</span>
<a name="l00655"></a>00655         <span class="comment">#    service = &quot;wise&quot;</span>
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         auth = dict(Email=credentials[0], Passwd=credentials[1], service=service, source=headers[<span class="stringliteral">&#39;user-agent&#39;</span>])
<a name="l00658"></a>00658         resp, content = self.http.request(<span class="stringliteral">&quot;https://www.google.com/accounts/ClientLogin&quot;</span>, method=<span class="stringliteral">&quot;POST&quot;</span>, body=urlencode(auth), headers={<span class="stringliteral">&#39;Content-Type&#39;</span>: <span class="stringliteral">&#39;application/x-www-form-urlencoded&#39;</span>})
<a name="l00659"></a>00659         lines = content.split(<span class="stringliteral">&#39;\n&#39;</span>)
<a name="l00660"></a>00660         d = dict([tuple(line.split(<span class="stringliteral">&quot;=&quot;</span>, 1)) <span class="keywordflow">for</span> line <span class="keywordflow">in</span> lines <span class="keywordflow">if</span> line])
<a name="l00661"></a>00661         <span class="keywordflow">if</span> resp.status == 403:
<a name="l00662"></a>00662             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1GoogleLoginAuthentication.html#aaee7708c94eb7399f40e1446eda08c95">Auth</a> = <span class="stringliteral">&quot;&quot;</span>
<a name="l00663"></a>00663         <span class="keywordflow">else</span>:
<a name="l00664"></a>00664             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1GoogleLoginAuthentication.html#aaee7708c94eb7399f40e1446eda08c95">Auth</a> = d[<span class="stringliteral">&#39;Auth&#39;</span>]
<a name="l00665"></a>00665 
<a name="l00666"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1GoogleLoginAuthentication.html#ae62f8cb859562953e90714f6b5550c68">00666</a>     <span class="keyword">def </span>request(self, method, request_uri, headers, content):
<a name="l00667"></a>00667         <span class="stringliteral">&quot;&quot;&quot;Modify the request headers to add the appropriate</span>
<a name="l00668"></a>00668 <span class="stringliteral">        Authorization header.&quot;&quot;&quot;</span>
<a name="l00669"></a>00669         headers[<span class="stringliteral">&#39;authorization&#39;</span>] = <span class="stringliteral">&#39;GoogleLogin Auth=&#39;</span> + self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1GoogleLoginAuthentication.html#aaee7708c94eb7399f40e1446eda08c95">Auth</a>
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 AUTH_SCHEME_CLASSES = {
<a name="l00673"></a>00673     <span class="stringliteral">&quot;basic&quot;</span>: BasicAuthentication,
<a name="l00674"></a>00674     <span class="stringliteral">&quot;wsse&quot;</span>: WsseAuthentication,
<a name="l00675"></a>00675     <span class="stringliteral">&quot;digest&quot;</span>: DigestAuthentication,
<a name="l00676"></a>00676     <span class="stringliteral">&quot;hmacdigest&quot;</span>: HmacDigestAuthentication,
<a name="l00677"></a>00677     <span class="stringliteral">&quot;googlelogin&quot;</span>: GoogleLoginAuthentication
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 AUTH_SCHEME_ORDER = [<span class="stringliteral">&quot;hmacdigest&quot;</span>, <span class="stringliteral">&quot;googlelogin&quot;</span>, <span class="stringliteral">&quot;digest&quot;</span>, <span class="stringliteral">&quot;wsse&quot;</span>, <span class="stringliteral">&quot;basic&quot;</span>]
<a name="l00681"></a>00681 
<a name="l00682"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html">00682</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html">FileCache</a>(object):
<a name="l00683"></a>00683     <span class="stringliteral">&quot;&quot;&quot;Uses a local directory as a store for cached files.</span>
<a name="l00684"></a>00684 <span class="stringliteral">    Not really safe to use if multiple threads or processes are going to</span>
<a name="l00685"></a>00685 <span class="stringliteral">    be running on the same cache.</span>
<a name="l00686"></a>00686 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00687"></a>00687     <span class="keyword">def </span>__init__(self, cache, safe=safename): <span class="comment"># use safe=lambda x: md5.new(x).hexdigest() for the old behavior</span>
<a name="l00688"></a>00688         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#aa54e4f1bada3fe86ccebe5ea3d390526">cache</a> = cache
<a name="l00689"></a>00689         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#a843f3a288dc34507fa4b389d19550bb8">safe</a> = safe
<a name="l00690"></a>00690         <span class="keywordflow">if</span> <span class="keywordflow">not</span> os.path.exists(cache):
<a name="l00691"></a>00691             os.makedirs(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#aa54e4f1bada3fe86ccebe5ea3d390526">cache</a>)
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="keyword">def </span>get(self, key):
<a name="l00694"></a>00694         retval = <span class="keywordtype">None</span>
<a name="l00695"></a>00695         cacheFullPath = os.path.join(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#aa54e4f1bada3fe86ccebe5ea3d390526">cache</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#a843f3a288dc34507fa4b389d19550bb8">safe</a>(key))
<a name="l00696"></a>00696         <span class="keywordflow">try</span>:
<a name="l00697"></a>00697             f = file(cacheFullPath, <span class="stringliteral">&quot;rb&quot;</span>)
<a name="l00698"></a>00698             retval = f.read()
<a name="l00699"></a>00699             f.close()
<a name="l00700"></a>00700         <span class="keywordflow">except</span> IOError:
<a name="l00701"></a>00701             <span class="keywordflow">pass</span>
<a name="l00702"></a>00702         <span class="keywordflow">return</span> retval
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="keyword">def </span>set(self, key, value):
<a name="l00705"></a>00705         cacheFullPath = os.path.join(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#aa54e4f1bada3fe86ccebe5ea3d390526">cache</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#a843f3a288dc34507fa4b389d19550bb8">safe</a>(key))
<a name="l00706"></a>00706         f = file(cacheFullPath, <span class="stringliteral">&quot;wb&quot;</span>)
<a name="l00707"></a>00707         f.write(value)
<a name="l00708"></a>00708         f.close()
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     <span class="keyword">def </span>delete(self, key):
<a name="l00711"></a>00711         cacheFullPath = os.path.join(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#aa54e4f1bada3fe86ccebe5ea3d390526">cache</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1FileCache.html#a843f3a288dc34507fa4b389d19550bb8">safe</a>(key))
<a name="l00712"></a>00712         <span class="keywordflow">if</span> os.path.exists(cacheFullPath):
<a name="l00713"></a>00713             os.remove(cacheFullPath)
<a name="l00714"></a>00714 
<a name="l00715"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html">00715</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html">Credentials</a>(object):
<a name="l00716"></a>00716     <span class="keyword">def </span>__init__(self):
<a name="l00717"></a>00717         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html#ad3ca5cb779125cc78de6889325391ca9">credentials</a> = []
<a name="l00718"></a>00718 
<a name="l00719"></a>00719     <span class="keyword">def </span>add(self, name, password, domain=&quot;&quot;):
<a name="l00720"></a>00720         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html#ad3ca5cb779125cc78de6889325391ca9">credentials</a>.append((domain.lower(), name, password))
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="keyword">def </span>clear(self):
<a name="l00723"></a>00723         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html#ad3ca5cb779125cc78de6889325391ca9">credentials</a> = []
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="keyword">def </span>iter(self, domain):
<a name="l00726"></a>00726         <span class="keywordflow">for</span> (cdomain, name, password) <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html#ad3ca5cb779125cc78de6889325391ca9">credentials</a>:
<a name="l00727"></a>00727             <span class="keywordflow">if</span> cdomain == <span class="stringliteral">&quot;&quot;</span> <span class="keywordflow">or</span> domain == cdomain:
<a name="l00728"></a>00728                 <span class="keywordflow">yield</span> (name, password)
<a name="l00729"></a>00729 
<a name="l00730"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1KeyCerts.html">00730</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1KeyCerts.html">KeyCerts</a>(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Credentials.html">Credentials</a>):
<a name="l00731"></a>00731     <span class="stringliteral">&quot;&quot;&quot;Identical to Credentials except that</span>
<a name="l00732"></a>00732 <span class="stringliteral">    name/password are mapped to key/cert.&quot;&quot;&quot;</span>
<a name="l00733"></a>00733     <span class="keywordflow">pass</span>
<a name="l00734"></a>00734 
<a name="l00735"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1AllHosts.html">00735</a> <span class="keyword">class </span>AllHosts(object):
<a name="l00736"></a>00736   <span class="keywordflow">pass</span>
<a name="l00737"></a>00737 
<a name="l00738"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html">00738</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html">ProxyInfo</a>(object):
<a name="l00739"></a>00739     <span class="stringliteral">&quot;&quot;&quot;Collect information required to use a proxy.&quot;&quot;&quot;</span>
<a name="l00740"></a>00740     bypass_hosts = ()
<a name="l00741"></a>00741 
<a name="l00742"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a84e7945da930a1750a3e198be8a3d6c9">00742</a>     <span class="keyword">def </span>__init__(self, proxy_type, proxy_host, proxy_port,
<a name="l00743"></a>00743         proxy_rdns=<span class="keywordtype">None</span>, proxy_user=<span class="keywordtype">None</span>, proxy_pass=<span class="keywordtype">None</span>):
<a name="l00744"></a>00744         <span class="stringliteral">&quot;&quot;&quot;The parameter proxy_type must be set to one of socks.PROXY_TYPE_XXX</span>
<a name="l00745"></a>00745 <span class="stringliteral">        constants. For example:</span>
<a name="l00746"></a>00746 <span class="stringliteral"></span>
<a name="l00747"></a>00747 <span class="stringliteral">        p = ProxyInfo(proxy_type=socks.PROXY_TYPE_HTTP,</span>
<a name="l00748"></a>00748 <span class="stringliteral">            proxy_host=&#39;localhost&#39;, proxy_port=8000)</span>
<a name="l00749"></a>00749 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00750"></a>00750         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a130953d944d94fd19d24f9bc3dc80ec9">proxy_type</a> = proxy_type
<a name="l00751"></a>00751         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ac838619ac5df62c008061930b32c1715">proxy_host</a> = proxy_host
<a name="l00752"></a>00752         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ab886a752eabed66c503e727a2fa9f885">proxy_port</a> = proxy_port
<a name="l00753"></a>00753         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ad80a18224e5473870cb7a0124fa8f25e">proxy_rdns</a> = proxy_rdns
<a name="l00754"></a>00754         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ad86d320f6d70779b8515fc7d3f6031eb">proxy_user</a> = proxy_user
<a name="l00755"></a>00755         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ae58d45b394a467d25cc29f6cf9c90e6e">proxy_pass</a> = proxy_pass
<a name="l00756"></a>00756 
<a name="l00757"></a>00757     <span class="keyword">def </span>astuple(self):
<a name="l00758"></a>00758         <span class="keywordflow">return</span> (self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a130953d944d94fd19d24f9bc3dc80ec9">proxy_type</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ac838619ac5df62c008061930b32c1715">proxy_host</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ab886a752eabed66c503e727a2fa9f885">proxy_port</a>,
<a name="l00759"></a>00759             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ad80a18224e5473870cb7a0124fa8f25e">proxy_rdns</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ad86d320f6d70779b8515fc7d3f6031eb">proxy_user</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ae58d45b394a467d25cc29f6cf9c90e6e">proxy_pass</a>)
<a name="l00760"></a>00760 
<a name="l00761"></a>00761     <span class="keyword">def </span>isgood(self):
<a name="l00762"></a>00762         <span class="keywordflow">return</span> (self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ac838619ac5df62c008061930b32c1715">proxy_host</a> != <span class="keywordtype">None</span>) <span class="keywordflow">and</span> (self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ab886a752eabed66c503e727a2fa9f885">proxy_port</a> != <span class="keywordtype">None</span>)
<a name="l00763"></a>00763 
<a name="l00764"></a>00764     @classmethod
<a name="l00765"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a08f0685a6c5079ef6374201599928ab4">00765</a>     <span class="keyword">def </span>from_environment(cls, method=&#39;http&#39;):
<a name="l00766"></a>00766         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00767"></a>00767 <span class="stringliteral">        Read proxy info from the environment variables.</span>
<a name="l00768"></a>00768 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00769"></a>00769         <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&#39;http&#39;</span>, <span class="stringliteral">&#39;https&#39;</span>]:
<a name="l00770"></a>00770           <span class="keywordflow">return</span>
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         env_var = method + <span class="stringliteral">&#39;_proxy&#39;</span>
<a name="l00773"></a>00773         url = os.environ.get(env_var, os.environ.get(env_var.upper()))
<a name="l00774"></a>00774         <span class="keywordflow">if</span> <span class="keywordflow">not</span> url:
<a name="l00775"></a>00775           <span class="keywordflow">return</span>
<a name="l00776"></a>00776         pi = cls.from_url(url, method)
<a name="l00777"></a>00777 
<a name="l00778"></a>00778         no_proxy = os.environ.get(<span class="stringliteral">&#39;no_proxy&#39;</span>, os.environ.get(<span class="stringliteral">&#39;NO_PROXY&#39;</span>, <span class="stringliteral">&#39;&#39;</span>))
<a name="l00779"></a>00779         bypass_hosts = []
<a name="l00780"></a>00780         <span class="keywordflow">if</span> no_proxy:
<a name="l00781"></a>00781           bypass_hosts = no_proxy.split(<span class="stringliteral">&#39;,&#39;</span>)
<a name="l00782"></a>00782         <span class="comment"># special case, no_proxy=* means all hosts bypassed</span>
<a name="l00783"></a>00783         <span class="keywordflow">if</span> no_proxy == <span class="stringliteral">&#39;*&#39;</span>:
<a name="l00784"></a>00784           bypass_hosts = AllHosts
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         pi.bypass_hosts = bypass_hosts
<a name="l00787"></a>00787         <span class="keywordflow">return</span> pi
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     @classmethod
<a name="l00790"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a9072f463868e6a1751acf635179a7270">00790</a>     <span class="keyword">def </span>from_url(cls, url, method=&#39;http&#39;):
<a name="l00791"></a>00791         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00792"></a>00792 <span class="stringliteral">        Construct a ProxyInfo from a URL (such as http_proxy env var)</span>
<a name="l00793"></a>00793 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00794"></a>00794         url = urlparse.urlparse(url)
<a name="l00795"></a>00795         username = <span class="keywordtype">None</span>
<a name="l00796"></a>00796         password = <span class="keywordtype">None</span>
<a name="l00797"></a>00797         port = <span class="keywordtype">None</span>
<a name="l00798"></a>00798         <span class="keywordflow">if</span> <span class="stringliteral">&#39;@&#39;</span> <span class="keywordflow">in</span> url[1]:
<a name="l00799"></a>00799           ident, host_port = url[1].split(<span class="stringliteral">&#39;@&#39;</span>, 1)
<a name="l00800"></a>00800           <span class="keywordflow">if</span> <span class="stringliteral">&#39;:&#39;</span> <span class="keywordflow">in</span> ident:
<a name="l00801"></a>00801             username, password = ident.split(<span class="stringliteral">&#39;:&#39;</span>, 1)
<a name="l00802"></a>00802           <span class="keywordflow">else</span>:
<a name="l00803"></a>00803             password = ident
<a name="l00804"></a>00804         <span class="keywordflow">else</span>:
<a name="l00805"></a>00805           host_port = url[1]
<a name="l00806"></a>00806         <span class="keywordflow">if</span> <span class="stringliteral">&#39;:&#39;</span> <span class="keywordflow">in</span> host_port:
<a name="l00807"></a>00807           host, port = host_port.split(<span class="stringliteral">&#39;:&#39;</span>, 1)
<a name="l00808"></a>00808         <span class="keywordflow">else</span>:
<a name="l00809"></a>00809           host = host_port
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         <span class="keywordflow">if</span> port:
<a name="l00812"></a>00812             port = int(port)
<a name="l00813"></a>00813         <span class="keywordflow">else</span>:
<a name="l00814"></a>00814             port = dict(https=443, http=80)[method]
<a name="l00815"></a>00815 
<a name="l00816"></a>00816         proxy_type = 3 <span class="comment"># socks.PROXY_TYPE_HTTP</span>
<a name="l00817"></a>00817         <span class="keywordflow">return</span> cls(
<a name="l00818"></a>00818             proxy_type = proxy_type,
<a name="l00819"></a>00819             proxy_host = host,
<a name="l00820"></a>00820             proxy_port = port,
<a name="l00821"></a>00821             proxy_user = username <span class="keywordflow">or</span> <span class="keywordtype">None</span>,
<a name="l00822"></a>00822             proxy_pass = password <span class="keywordflow">or</span> <span class="keywordtype">None</span>,
<a name="l00823"></a>00823         )
<a name="l00824"></a>00824 
<a name="l00825"></a>00825     <span class="keyword">def </span>applies_to(self, hostname):
<a name="l00826"></a>00826         <span class="keywordflow">return</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a75681f23569f4d216102eb42f8e92bd9">bypass_host</a>(hostname)
<a name="l00827"></a>00827 
<a name="l00828"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#a75681f23569f4d216102eb42f8e92bd9">00828</a>     <span class="keyword">def </span>bypass_host(self, hostname):
<a name="l00829"></a>00829         <span class="stringliteral">&quot;&quot;&quot;Has this host been excluded from the proxy config&quot;&quot;&quot;</span>
<a name="l00830"></a>00830         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ab2256fa79cad22b1944c0c8a44ac9417">bypass_hosts</a> <span class="keywordflow">is</span> AllHosts:
<a name="l00831"></a>00831           <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         bypass = <span class="keyword">False</span>
<a name="l00834"></a>00834         <span class="keywordflow">for</span> domain <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ProxyInfo.html#ab2256fa79cad22b1944c0c8a44ac9417">bypass_hosts</a>:
<a name="l00835"></a>00835           <span class="keywordflow">if</span> hostname.endswith(domain):
<a name="l00836"></a>00836             bypass = <span class="keyword">True</span>
<a name="l00837"></a>00837 
<a name="l00838"></a>00838         <span class="keywordflow">return</span> bypass
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 
<a name="l00841"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html">00841</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html">HTTPConnectionWithTimeout</a>(httplib.HTTPConnection):
<a name="l00842"></a>00842     <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00843"></a>00843 <span class="stringliteral">    HTTPConnection subclass that supports timeouts</span>
<a name="l00844"></a>00844 <span class="stringliteral"></span>
<a name="l00845"></a>00845 <span class="stringliteral">    All timeouts are in seconds. If None is passed for timeout then</span>
<a name="l00846"></a>00846 <span class="stringliteral">    Python&#39;s default timeout for sockets will be used. See for example</span>
<a name="l00847"></a>00847 <span class="stringliteral">    the docs of socket.setdefaulttimeout():</span>
<a name="l00848"></a>00848 <span class="stringliteral">    http://docs.python.org/library/socket.html#socket.setdefaulttimeout</span>
<a name="l00849"></a>00849 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     <span class="keyword">def </span>__init__(self, host, port=None, strict=None, timeout=None, proxy_info=None):
<a name="l00852"></a>00852         httplib.HTTPConnection.__init__(self, host, port, strict)
<a name="l00853"></a>00853         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a8f59f24e9dea54f32343562f21ff4729">timeout</a> = timeout
<a name="l00854"></a>00854         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a9f4c0ced3cacead03bd54ca828a379b6">proxy_info</a> = proxy_info
<a name="l00855"></a>00855 
<a name="l00856"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#abaa6862eaa3e69553b9e050d4542f951">00856</a>     <span class="keyword">def </span>connect(self):
<a name="l00857"></a>00857         <span class="stringliteral">&quot;&quot;&quot;Connect to the host and port specified in __init__.&quot;&quot;&quot;</span>
<a name="l00858"></a>00858         <span class="comment"># Mostly verbatim from httplib.py.</span>
<a name="l00859"></a>00859         <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a9f4c0ced3cacead03bd54ca828a379b6">proxy_info</a> <span class="keywordflow">and</span> socks <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00860"></a>00860             <span class="keywordflow">raise</span> ProxiesUnavailableError(
<a name="l00861"></a>00861                 <span class="stringliteral">&#39;Proxy support missing but proxy use was requested!&#39;</span>)
<a name="l00862"></a>00862         msg = <span class="stringliteral">&quot;getaddrinfo returns an empty list&quot;</span>
<a name="l00863"></a>00863         <span class="keywordflow">for</span> res <span class="keywordflow">in</span> socket.getaddrinfo(self.host, self.port, 0,
<a name="l00864"></a>00864                 socket.SOCK_STREAM):
<a name="l00865"></a>00865             af, socktype, proto, canonname, sa = res
<a name="l00866"></a>00866             <span class="keywordflow">try</span>:
<a name="l00867"></a>00867                 <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a9f4c0ced3cacead03bd54ca828a379b6">proxy_info</a> <span class="keywordflow">and</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a9f4c0ced3cacead03bd54ca828a379b6">proxy_info</a>.isgood():
<a name="l00868"></a>00868                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a> = socks.socksocket(af, socktype, proto)
<a name="l00869"></a>00869                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>.setproxy(*self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a9f4c0ced3cacead03bd54ca828a379b6">proxy_info</a>.astuple())
<a name="l00870"></a>00870                 <span class="keywordflow">else</span>:
<a name="l00871"></a>00871                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a> = socket.socket(af, socktype, proto)
<a name="l00872"></a>00872                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
<a name="l00873"></a>00873                 <span class="comment"># Different from httplib: support timeouts.</span>
<a name="l00874"></a>00874                 <span class="keywordflow">if</span> has_timeout(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a8f59f24e9dea54f32343562f21ff4729">timeout</a>):
<a name="l00875"></a>00875                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>.settimeout(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a8f59f24e9dea54f32343562f21ff4729">timeout</a>)
<a name="l00876"></a>00876                     <span class="comment"># End of difference from httplib.</span>
<a name="l00877"></a>00877                 <span class="keywordflow">if</span> self.debuglevel &gt; 0:
<a name="l00878"></a>00878                     <span class="keywordflow">print</span> <span class="stringliteral">&quot;connect: (%s, %s)&quot;</span> % (self.host, self.port)
<a name="l00879"></a>00879 
<a name="l00880"></a>00880                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>.connect((self.host, self.port) + sa[2:])
<a name="l00881"></a>00881             <span class="keywordflow">except</span> socket.error, msg:
<a name="l00882"></a>00882                 <span class="keywordflow">if</span> self.debuglevel &gt; 0:
<a name="l00883"></a>00883                     <span class="keywordflow">print</span> <span class="stringliteral">&#39;connect fail:&#39;</span>, (self.host, self.port)
<a name="l00884"></a>00884                 <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>:
<a name="l00885"></a>00885                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>.close()
<a name="l00886"></a>00886                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a> = <span class="keywordtype">None</span>
<a name="l00887"></a>00887                 <span class="keywordflow">continue</span>
<a name="l00888"></a>00888             <span class="keywordflow">break</span>
<a name="l00889"></a>00889         <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPConnectionWithTimeout.html#a175d0e6936c20565f6054bd136d4761b">sock</a>:
<a name="l00890"></a>00890             <span class="keywordflow">raise</span> socket.error, msg
<a name="l00891"></a>00891 
<a name="l00892"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html">00892</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html">HTTPSConnectionWithTimeout</a>(httplib.HTTPSConnection):
<a name="l00893"></a>00893     <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00894"></a>00894 <span class="stringliteral">    This class allows communication via SSL.</span>
<a name="l00895"></a>00895 <span class="stringliteral"></span>
<a name="l00896"></a>00896 <span class="stringliteral">    All timeouts are in seconds. If None is passed for timeout then</span>
<a name="l00897"></a>00897 <span class="stringliteral">    Python&#39;s default timeout for sockets will be used. See for example</span>
<a name="l00898"></a>00898 <span class="stringliteral">    the docs of socket.setdefaulttimeout():</span>
<a name="l00899"></a>00899 <span class="stringliteral">    http://docs.python.org/library/socket.html#socket.setdefaulttimeout</span>
<a name="l00900"></a>00900 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00901"></a>00901     <span class="keyword">def </span>__init__(self, host, port=None, key_file=None, cert_file=None,
<a name="l00902"></a>00902                  strict=<span class="keywordtype">None</span>, timeout=<span class="keywordtype">None</span>, proxy_info=<span class="keywordtype">None</span>,
<a name="l00903"></a>00903                  ca_certs=<span class="keywordtype">None</span>, disable_ssl_certificate_validation=<span class="keyword">False</span>):
<a name="l00904"></a>00904         httplib.HTTPSConnection.__init__(self, host, port=port, key_file=key_file,
<a name="l00905"></a>00905                 cert_file=cert_file, strict=strict)
<a name="l00906"></a>00906         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a1c9ee008d7ca76d90d462f5c3a8ee32d">timeout</a> = timeout
<a name="l00907"></a>00907         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a0760df1a2f70c507c1e878a162323478">proxy_info</a> = proxy_info
<a name="l00908"></a>00908         <span class="keywordflow">if</span> ca_certs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00909"></a>00909           ca_certs = CA_CERTS
<a name="l00910"></a>00910         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ac4f8193accf2e3d3ee462cea1138528c">ca_certs</a> = ca_certs
<a name="l00911"></a>00911         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a054ca9974d9a45db052bd62a787d4f65">disable_ssl_certificate_validation</a> = \
<a name="l00912"></a>00912                 disable_ssl_certificate_validation
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     <span class="comment"># The following two methods were adapted from https_wrapper.py, released</span>
<a name="l00915"></a>00915     <span class="comment"># with the Google Appengine SDK at</span>
<a name="l00916"></a>00916     <span class="comment"># http://googleappengine.googlecode.com/svn-history/r136/trunk/python/google/appengine/tools/https_wrapper.py</span>
<a name="l00917"></a>00917     <span class="comment"># under the following license:</span>
<a name="l00918"></a>00918     <span class="comment">#</span>
<a name="l00919"></a>00919     <span class="comment"># Copyright 2007 Google Inc.</span>
<a name="l00920"></a>00920     <span class="comment">#</span>
<a name="l00921"></a>00921     <span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<a name="l00922"></a>00922     <span class="comment"># you may not use this file except in compliance with the License.</span>
<a name="l00923"></a>00923     <span class="comment"># You may obtain a copy of the License at</span>
<a name="l00924"></a>00924     <span class="comment">#</span>
<a name="l00925"></a>00925     <span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00926"></a>00926     <span class="comment">#</span>
<a name="l00927"></a>00927     <span class="comment"># Unless required by applicable law or agreed to in writing, software</span>
<a name="l00928"></a>00928     <span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<a name="l00929"></a>00929     <span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00930"></a>00930     <span class="comment"># See the License for the specific language governing permissions and</span>
<a name="l00931"></a>00931     <span class="comment"># limitations under the License.</span>
<a name="l00932"></a>00932     <span class="comment">#</span>
<a name="l00933"></a>00933 
<a name="l00934"></a>00934     <span class="keyword">def </span>_GetValidHostsForCert(self, cert):
<a name="l00935"></a>00935         <span class="stringliteral">&quot;&quot;&quot;Returns a list of valid host globs for an SSL certificate.</span>
<a name="l00936"></a>00936 <span class="stringliteral"></span>
<a name="l00937"></a>00937 <span class="stringliteral">        Args:</span>
<a name="l00938"></a>00938 <span class="stringliteral">          cert: A dictionary representing an SSL certificate.</span>
<a name="l00939"></a>00939 <span class="stringliteral">        Returns:</span>
<a name="l00940"></a>00940 <span class="stringliteral">          list: A list of valid host globs.</span>
<a name="l00941"></a>00941 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00942"></a>00942         <span class="keywordflow">if</span> <span class="stringliteral">&#39;subjectAltName&#39;</span> <span class="keywordflow">in</span> cert:
<a name="l00943"></a>00943             <span class="keywordflow">return</span> [x[1] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> cert[<span class="stringliteral">&#39;subjectAltName&#39;</span>]
<a name="l00944"></a>00944                     <span class="keywordflow">if</span> x[0].lower() == <span class="stringliteral">&#39;dns&#39;</span>]
<a name="l00945"></a>00945         <span class="keywordflow">else</span>:
<a name="l00946"></a>00946             <span class="keywordflow">return</span> [x[0][1] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> cert[<span class="stringliteral">&#39;subject&#39;</span>]
<a name="l00947"></a>00947                     <span class="keywordflow">if</span> x[0][0].lower() == <span class="stringliteral">&#39;commonname&#39;</span>]
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     <span class="keyword">def </span>_ValidateCertificateHostname(self, cert, hostname):
<a name="l00950"></a>00950         <span class="stringliteral">&quot;&quot;&quot;Validates that a given hostname is valid for an SSL certificate.</span>
<a name="l00951"></a>00951 <span class="stringliteral"></span>
<a name="l00952"></a>00952 <span class="stringliteral">        Args:</span>
<a name="l00953"></a>00953 <span class="stringliteral">          cert: A dictionary representing an SSL certificate.</span>
<a name="l00954"></a>00954 <span class="stringliteral">          hostname: The hostname to test.</span>
<a name="l00955"></a>00955 <span class="stringliteral">        Returns:</span>
<a name="l00956"></a>00956 <span class="stringliteral">          bool: Whether or not the hostname is valid for this certificate.</span>
<a name="l00957"></a>00957 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00958"></a>00958         hosts = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a83853e3e7779d64fdeab62778b45356f">_GetValidHostsForCert</a>(cert)
<a name="l00959"></a>00959         <span class="keywordflow">for</span> host <span class="keywordflow">in</span> hosts:
<a name="l00960"></a>00960             host_re = host.replace(<span class="stringliteral">&#39;.&#39;</span>, <span class="stringliteral">&#39;\.&#39;</span>).replace(<span class="stringliteral">&#39;*&#39;</span>, <span class="stringliteral">&#39;[^.]*&#39;</span>)
<a name="l00961"></a>00961             <span class="keywordflow">if</span> re.search(<span class="stringliteral">&#39;^%s$&#39;</span> % (host_re,), hostname, re.I):
<a name="l00962"></a>00962                 <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l00963"></a>00963         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l00964"></a>00964 
<a name="l00965"></a>00965     <span class="keyword">def </span>connect(self):
<a name="l00966"></a>00966         <span class="stringliteral">&quot;Connect to a host on a given (SSL) port.&quot;</span>
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         msg = <span class="stringliteral">&quot;getaddrinfo returns an empty list&quot;</span>
<a name="l00969"></a>00969         <span class="keywordflow">for</span> family, socktype, proto, canonname, sockaddr <span class="keywordflow">in</span> socket.getaddrinfo(
<a name="l00970"></a>00970             self.host, self.port, 0, socket.SOCK_STREAM):
<a name="l00971"></a>00971             <span class="keywordflow">try</span>:
<a name="l00972"></a>00972                 <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a0760df1a2f70c507c1e878a162323478">proxy_info</a> <span class="keywordflow">and</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a0760df1a2f70c507c1e878a162323478">proxy_info</a>.isgood():
<a name="l00973"></a>00973                     sock = socks.socksocket(family, socktype, proto)
<a name="l00974"></a>00974                     sock.setproxy(*self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a0760df1a2f70c507c1e878a162323478">proxy_info</a>.astuple())
<a name="l00975"></a>00975                 <span class="keywordflow">else</span>:
<a name="l00976"></a>00976                     sock = socket.socket(family, socktype, proto)
<a name="l00977"></a>00977                     sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
<a name="l00978"></a>00978 
<a name="l00979"></a>00979                 <span class="keywordflow">if</span> has_timeout(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a1c9ee008d7ca76d90d462f5c3a8ee32d">timeout</a>):
<a name="l00980"></a>00980                     sock.settimeout(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a1c9ee008d7ca76d90d462f5c3a8ee32d">timeout</a>)
<a name="l00981"></a>00981                 sock.connect((self.host, self.port))
<a name="l00982"></a>00982                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a> =_ssl_wrap_socket(
<a name="l00983"></a>00983                     sock, self.key_file, self.cert_file,
<a name="l00984"></a>00984                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a054ca9974d9a45db052bd62a787d4f65">disable_ssl_certificate_validation</a>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ac4f8193accf2e3d3ee462cea1138528c">ca_certs</a>)
<a name="l00985"></a>00985                 <span class="keywordflow">if</span> self.debuglevel &gt; 0:
<a name="l00986"></a>00986                     <span class="keywordflow">print</span> <span class="stringliteral">&quot;connect: (%s, %s)&quot;</span> % (self.host, self.port)
<a name="l00987"></a>00987                 <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a054ca9974d9a45db052bd62a787d4f65">disable_ssl_certificate_validation</a>:
<a name="l00988"></a>00988                     cert = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a>.getpeercert()
<a name="l00989"></a>00989                     hostname = self.host.split(<span class="stringliteral">&#39;:&#39;</span>, 0)[0]
<a name="l00990"></a>00990                     <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#a1e23771cce39ba06b24c3e23e0e80c64">_ValidateCertificateHostname</a>(cert, hostname):
<a name="l00991"></a>00991                         <span class="keywordflow">raise</span> CertificateHostnameMismatch(
<a name="l00992"></a>00992                             <span class="stringliteral">&#39;Server presented certificate that does not match &#39;</span>
<a name="l00993"></a>00993                             <span class="stringliteral">&#39;host %s: %s&#39;</span> % (hostname, cert), hostname, cert)
<a name="l00994"></a>00994             <span class="keywordflow">except</span> ssl_SSLError, e:
<a name="l00995"></a>00995                 <span class="keywordflow">if</span> sock:
<a name="l00996"></a>00996                     sock.close()
<a name="l00997"></a>00997                 <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a>:
<a name="l00998"></a>00998                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a>.close()
<a name="l00999"></a>00999                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a> = <span class="keywordtype">None</span>
<a name="l01000"></a>01000                 <span class="comment"># Unfortunately the ssl module doesn&#39;t seem to provide any way</span>
<a name="l01001"></a>01001                 <span class="comment"># to get at more detailed error information, in particular</span>
<a name="l01002"></a>01002                 <span class="comment"># whether the error is due to certificate validation or</span>
<a name="l01003"></a>01003                 <span class="comment"># something else (such as SSL protocol mismatch).</span>
<a name="l01004"></a>01004                 <span class="keywordflow">if</span> e.errno == ssl.SSL_ERROR_SSL:
<a name="l01005"></a>01005                     <span class="keywordflow">raise</span> SSLHandshakeError(e)
<a name="l01006"></a>01006                 <span class="keywordflow">else</span>:
<a name="l01007"></a>01007                     <span class="keywordflow">raise</span>
<a name="l01008"></a>01008             <span class="keywordflow">except</span> (socket.timeout, socket.gaierror):
<a name="l01009"></a>01009               <span class="keywordflow">raise</span>
<a name="l01010"></a>01010             <span class="keywordflow">except</span> socket.error, msg:
<a name="l01011"></a>01011               <span class="keywordflow">if</span> self.debuglevel &gt; 0:
<a name="l01012"></a>01012                   <span class="keywordflow">print</span> <span class="stringliteral">&#39;connect fail:&#39;</span>, (self.host, self.port)
<a name="l01013"></a>01013               <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a>:
<a name="l01014"></a>01014                   self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a>.close()
<a name="l01015"></a>01015               self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a> = <span class="keywordtype">None</span>
<a name="l01016"></a>01016               <span class="keywordflow">continue</span>
<a name="l01017"></a>01017             <span class="keywordflow">break</span>
<a name="l01018"></a>01018         <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1HTTPSConnectionWithTimeout.html#ad55c15bfeed4c6dc6606e05a750b47ee">sock</a>:
<a name="l01019"></a>01019           <span class="keywordflow">raise</span> socket.error, msg
<a name="l01020"></a>01020 
<a name="l01021"></a>01021 SCHEME_TO_CONNECTION = {
<a name="l01022"></a>01022     <span class="stringliteral">&#39;http&#39;</span>: HTTPConnectionWithTimeout,
<a name="l01023"></a>01023     <span class="stringliteral">&#39;https&#39;</span>: HTTPSConnectionWithTimeout
<a name="l01024"></a>01024     }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="comment"># Use a different connection object for Google App Engine</span>
<a name="l01027"></a>01027 <span class="keywordflow">try</span>:
<a name="l01028"></a>01028   <span class="keyword">from</span> google.appengine.api <span class="keyword">import</span> apiproxy_stub_map
<a name="l01029"></a>01029   <span class="keywordflow">if</span> apiproxy_stub_map.apiproxy.GetStub(<span class="stringliteral">&#39;urlfetch&#39;</span>) <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01030"></a>01030     <span class="keywordflow">raise</span> ImportError  <span class="comment"># Bail out; we&#39;re not actually running on App Engine.</span>
<a name="l01031"></a>01031   <span class="keyword">from</span> google.appengine.api.urlfetch <span class="keyword">import</span> fetch
<a name="l01032"></a>01032   <span class="keyword">from</span> google.appengine.api.urlfetch <span class="keyword">import</span> InvalidURLError
<a name="l01033"></a>01033   <span class="keyword">from</span> google.appengine.api.urlfetch <span class="keyword">import</span> DownloadError
<a name="l01034"></a>01034   <span class="keyword">from</span> google.appengine.api.urlfetch <span class="keyword">import</span> ResponseTooLargeError
<a name="l01035"></a>01035   <span class="keyword">from</span> google.appengine.api.urlfetch <span class="keyword">import</span> SSLCertificateError
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 
<a name="l01038"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ResponseDict.html">01038</a>   <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1ResponseDict.html">ResponseDict</a>(dict):
<a name="l01039"></a>01039     <span class="stringliteral">&quot;&quot;&quot;Is a dictionary that also has a read() method, so</span>
<a name="l01040"></a>01040 <span class="stringliteral">    that it can pass itself off as an httlib.HTTPResponse().&quot;&quot;&quot;</span>
<a name="l01041"></a>01041     <span class="keyword">def </span>read(self):
<a name="l01042"></a>01042       <span class="keywordflow">pass</span>
<a name="l01043"></a>01043 
<a name="l01044"></a>01044 
<a name="l01045"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1AppEngineHttpConnection.html">01045</a>   <span class="keyword">class </span>AppEngineHttpConnection(object):
<a name="l01046"></a>01046     <span class="stringliteral">&quot;&quot;&quot;Emulates an httplib.HTTPConnection object, but actually uses the Google</span>
<a name="l01047"></a>01047 <span class="stringliteral">    App Engine urlfetch library. This allows the timeout to be properly used on</span>
<a name="l01048"></a>01048 <span class="stringliteral">    Google App Engine, and avoids using httplib, which on Google App Engine is</span>
<a name="l01049"></a>01049 <span class="stringliteral">    just another wrapper around urlfetch.</span>
<a name="l01050"></a>01050 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l01051"></a>01051     <span class="keyword">def </span>__init__(self, host, port=None, key_file=None, cert_file=None,
<a name="l01052"></a>01052                  strict=<span class="keywordtype">None</span>, timeout=<span class="keywordtype">None</span>, proxy_info=<span class="keywordtype">None</span>, ca_certs=<span class="keywordtype">None</span>,
<a name="l01053"></a>01053                  disable_certificate_validation=<span class="keyword">False</span>):
<a name="l01054"></a>01054       self.host = host
<a name="l01055"></a>01055       self.port = port
<a name="l01056"></a>01056       self.timeout = timeout
<a name="l01057"></a>01057       <span class="keywordflow">if</span> key_file <span class="keywordflow">or</span> cert_file <span class="keywordflow">or</span> proxy_info <span class="keywordflow">or</span> ca_certs:
<a name="l01058"></a>01058         <span class="keywordflow">raise</span> NotSupportedOnThisPlatform()
<a name="l01059"></a>01059       self.response = <span class="keywordtype">None</span>
<a name="l01060"></a>01060       self.scheme = <span class="stringliteral">&#39;http&#39;</span>
<a name="l01061"></a>01061       self.validate_certificate = <span class="keywordflow">not</span> disable_certificate_validation
<a name="l01062"></a>01062       self.sock = <span class="keyword">True</span>
<a name="l01063"></a>01063 
<a name="l01064"></a>01064     <span class="keyword">def </span>request(self, method, url, body, headers):
<a name="l01065"></a>01065       <span class="comment"># Calculate the absolute URI, which fetch requires</span>
<a name="l01066"></a>01066       netloc = self.host
<a name="l01067"></a>01067       <span class="keywordflow">if</span> self.port:
<a name="l01068"></a>01068         netloc = <span class="stringliteral">&#39;%s:%s&#39;</span> % (self.host, self.port)
<a name="l01069"></a>01069       absolute_uri = <span class="stringliteral">&#39;%s://%s%s&#39;</span> % (self.scheme, netloc, url)
<a name="l01070"></a>01070       <span class="keywordflow">try</span>:
<a name="l01071"></a>01071         response = fetch(absolute_uri, payload=body, method=method,
<a name="l01072"></a>01072             headers=headers, allow_truncated=<span class="keyword">False</span>, follow_redirects=<span class="keyword">False</span>,
<a name="l01073"></a>01073             deadline=self.timeout,
<a name="l01074"></a>01074             validate_certificate=self.validate_certificate)
<a name="l01075"></a>01075         self.response = ResponseDict(response.headers)
<a name="l01076"></a>01076         self.response[<span class="stringliteral">&#39;status&#39;</span>] = str(response.status_code)
<a name="l01077"></a>01077         self.response.status = response.status_code
<a name="l01078"></a>01078         setattr(self.response, <span class="stringliteral">&#39;read&#39;</span>, <span class="keyword">lambda</span> : response.content)
<a name="l01079"></a>01079 
<a name="l01080"></a>01080       <span class="comment"># Make sure the exceptions raised match the exceptions expected.</span>
<a name="l01081"></a>01081       <span class="keywordflow">except</span> InvalidURLError:
<a name="l01082"></a>01082         <span class="keywordflow">raise</span> socket.gaierror(<span class="stringliteral">&#39;&#39;</span>)
<a name="l01083"></a>01083       <span class="keywordflow">except</span> (DownloadError, ResponseTooLargeError, SSLCertificateError):
<a name="l01084"></a>01084         <span class="keywordflow">raise</span> httplib.HTTPException()
<a name="l01085"></a>01085 
<a name="l01086"></a>01086     <span class="keyword">def </span>getresponse(self):
<a name="l01087"></a>01087       <span class="keywordflow">if</span> self.response:
<a name="l01088"></a>01088         <span class="keywordflow">return</span> self.response
<a name="l01089"></a>01089       <span class="keywordflow">else</span>:
<a name="l01090"></a>01090         <span class="keywordflow">raise</span> httplib.HTTPException()
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     <span class="keyword">def </span>set_debuglevel(self, level):
<a name="l01093"></a>01093       <span class="keywordflow">pass</span>
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="keyword">def </span>connect(self):
<a name="l01096"></a>01096       <span class="keywordflow">pass</span>
<a name="l01097"></a>01097 
<a name="l01098"></a>01098     <span class="keyword">def </span>close(self):
<a name="l01099"></a>01099       <span class="keywordflow">pass</span>
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 
<a name="l01102"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1AppEngineHttpConnection_1_1AppEngineHttpsConnection.html">01102</a>   <span class="keyword">class </span>AppEngineHttpsConnection(<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1AppEngineHttpConnection.html">AppEngineHttpConnection</a>):
<a name="l01103"></a>01103     <span class="stringliteral">&quot;&quot;&quot;Same as AppEngineHttpConnection, but for HTTPS URIs.&quot;&quot;&quot;</span>
<a name="l01104"></a>01104     <span class="keyword">def </span>__init__(self, host, port=None, key_file=None, cert_file=None,
<a name="l01105"></a>01105                  strict=<span class="keywordtype">None</span>, timeout=<span class="keywordtype">None</span>, proxy_info=<span class="keywordtype">None</span>):
<a name="l01106"></a>01106       AppEngineHttpConnection.__init__(self, host, port, key_file, cert_file,
<a name="l01107"></a>01107           strict, timeout, proxy_info)
<a name="l01108"></a>01108       self.scheme = <span class="stringliteral">&#39;https&#39;</span>
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   <span class="comment"># Update the connection classes to use the Googel App Engine specific ones.</span>
<a name="l01111"></a>01111   SCHEME_TO_CONNECTION = {
<a name="l01112"></a>01112       <span class="stringliteral">&#39;http&#39;</span>: AppEngineHttpConnection,
<a name="l01113"></a>01113       <span class="stringliteral">&#39;https&#39;</span>: AppEngineHttpsConnection
<a name="l01114"></a>01114       }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 <span class="keywordflow">except</span> ImportError:
<a name="l01117"></a>01117   <span class="keywordflow">pass</span>
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 
<a name="l01120"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html">01120</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html">Http</a>(object):
<a name="l01121"></a>01121     <span class="stringliteral">&quot;&quot;&quot;An HTTP client that handles:</span>
<a name="l01122"></a>01122 <span class="stringliteral">- all methods</span>
<a name="l01123"></a>01123 <span class="stringliteral">- caching</span>
<a name="l01124"></a>01124 <span class="stringliteral">- ETags</span>
<a name="l01125"></a>01125 <span class="stringliteral">- compression,</span>
<a name="l01126"></a>01126 <span class="stringliteral">- HTTPS</span>
<a name="l01127"></a>01127 <span class="stringliteral">- Basic</span>
<a name="l01128"></a>01128 <span class="stringliteral">- Digest</span>
<a name="l01129"></a>01129 <span class="stringliteral">- WSSE</span>
<a name="l01130"></a>01130 <span class="stringliteral"></span>
<a name="l01131"></a>01131 <span class="stringliteral">and more.</span>
<a name="l01132"></a>01132 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l01133"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ac86de2da30d99efee3d15ba1843ebba9">01133</a>     <span class="keyword">def </span>__init__(self, cache=None, timeout=None,
<a name="l01134"></a>01134                  proxy_info=ProxyInfo.from_environment,
<a name="l01135"></a>01135                  ca_certs=<span class="keywordtype">None</span>, disable_ssl_certificate_validation=<span class="keyword">False</span>):
<a name="l01136"></a>01136         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l01137"></a>01137 <span class="stringliteral">        If &#39;cache&#39; is a string then it is used as a directory name for</span>
<a name="l01138"></a>01138 <span class="stringliteral">        a disk cache. Otherwise it must be an object that supports the</span>
<a name="l01139"></a>01139 <span class="stringliteral">        same interface as FileCache.</span>
<a name="l01140"></a>01140 <span class="stringliteral"></span>
<a name="l01141"></a>01141 <span class="stringliteral">        All timeouts are in seconds. If None is passed for timeout</span>
<a name="l01142"></a>01142 <span class="stringliteral">        then Python&#39;s default timeout for sockets will be used. See</span>
<a name="l01143"></a>01143 <span class="stringliteral">        for example the docs of socket.setdefaulttimeout():</span>
<a name="l01144"></a>01144 <span class="stringliteral">        http://docs.python.org/library/socket.html#socket.setdefaulttimeout</span>
<a name="l01145"></a>01145 <span class="stringliteral"></span>
<a name="l01146"></a>01146 <span class="stringliteral">        `proxy_info` may be:</span>
<a name="l01147"></a>01147 <span class="stringliteral">          - a callable that takes the http scheme (&#39;http&#39; or &#39;https&#39;) and</span>
<a name="l01148"></a>01148 <span class="stringliteral">            returns a ProxyInfo instance per request. By default, uses</span>
<a name="l01149"></a>01149 <span class="stringliteral">            ProxyInfo.from_environment.</span>
<a name="l01150"></a>01150 <span class="stringliteral">          - a ProxyInfo instance (static proxy config).</span>
<a name="l01151"></a>01151 <span class="stringliteral">          - None (proxy disabled).</span>
<a name="l01152"></a>01152 <span class="stringliteral"></span>
<a name="l01153"></a>01153 <span class="stringliteral">        ca_certs is the path of a file containing root CA certificates for SSL</span>
<a name="l01154"></a>01154 <span class="stringliteral">        server certificate validation.  By default, a CA cert file bundled with</span>
<a name="l01155"></a>01155 <span class="stringliteral">        httplib2 is used.</span>
<a name="l01156"></a>01156 <span class="stringliteral"></span>
<a name="l01157"></a>01157 <span class="stringliteral">        If disable_ssl_certificate_validation is true, SSL cert validation will</span>
<a name="l01158"></a>01158 <span class="stringliteral">        not be performed.</span>
<a name="l01159"></a>01159 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01160"></a>01160         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#abcb995a725a6ad00939745934050582a">proxy_info</a> = proxy_info
<a name="l01161"></a>01161         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ac1a290abe26c3ce80aca21dcc54814b8">ca_certs</a> = ca_certs
<a name="l01162"></a>01162         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ab153c992218f0e7e9d4bf7c8a332913c">disable_ssl_certificate_validation</a> = \
<a name="l01163"></a>01163                 disable_ssl_certificate_validation
<a name="l01164"></a>01164 
<a name="l01165"></a>01165         <span class="comment"># Map domain name to an httplib connection</span>
<a name="l01166"></a>01166         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aebc22aef6735e295dfcc8a670228e0bf">connections</a> = {}
<a name="l01167"></a>01167         <span class="comment"># The location of the cache, for now a directory</span>
<a name="l01168"></a>01168         <span class="comment"># where cached responses are held.</span>
<a name="l01169"></a>01169         <span class="keywordflow">if</span> cache <span class="keywordflow">and</span> isinstance(cache, basestring):
<a name="l01170"></a>01170             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a> = FileCache(cache)
<a name="l01171"></a>01171         <span class="keywordflow">else</span>:
<a name="l01172"></a>01172             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a> = cache
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="comment"># Name/password</span>
<a name="l01175"></a>01175         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a033b5599dc21cdd04ad0e7db9d5b9890">credentials</a> = Credentials()
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         <span class="comment"># Key/cert</span>
<a name="l01178"></a>01178         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#afe75200efff6d8f13efca6400b46f071">certificates</a> = KeyCerts()
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         <span class="comment"># authorization objects</span>
<a name="l01181"></a>01181         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a5e76c7ec1c3c4261a10e29b4ee3e1923">authorizations</a> = []
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         <span class="comment"># If set to False then no redirects are followed, even safe ones.</span>
<a name="l01184"></a>01184         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a1c9ba7f285fa007ae0e566dfa1393c59">follow_redirects</a> = <span class="keyword">True</span>
<a name="l01185"></a>01185 
<a name="l01186"></a>01186         <span class="comment"># Which HTTP methods do we apply optimistic concurrency to, i.e.</span>
<a name="l01187"></a>01187         <span class="comment"># which methods get an &quot;if-match:&quot; etag header added to them.</span>
<a name="l01188"></a>01188         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a4bd045145f8ee8f348ddd8c5c89e4231">optimistic_concurrency_methods</a> = [<span class="stringliteral">&quot;PUT&quot;</span>, <span class="stringliteral">&quot;PATCH&quot;</span>]
<a name="l01189"></a>01189 
<a name="l01190"></a>01190         <span class="comment"># If &#39;follow_redirects&#39; is True, and this is set to True then</span>
<a name="l01191"></a>01191         <span class="comment"># all redirecs are followed, including unsafe ones.</span>
<a name="l01192"></a>01192         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a8fa11f25b3c8f9036e07abdbdca9d355">follow_all_redirects</a> = <span class="keyword">False</span>
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#acb5a36a64ccc7e47b76de6276aa452f2">ignore_etag</a> = <span class="keyword">False</span>
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a4467a06f9145e1a71173d6207f7d5359">force_exception_to_status_code</a> = <span class="keyword">False</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aa5769edb4b915ce0fb3b652501ec3a0d">timeout</a> = timeout
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     <span class="keyword">def </span>_auth_from_challenge(self, host, request_uri, headers, response, content):
<a name="l01201"></a>01201         <span class="stringliteral">&quot;&quot;&quot;A generator that creates Authorization objects</span>
<a name="l01202"></a>01202 <span class="stringliteral">           that can be applied to requests.</span>
<a name="l01203"></a>01203 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01204"></a>01204         challenges = _parse_www_authenticate(response, <span class="stringliteral">&#39;www-authenticate&#39;</span>)
<a name="l01205"></a>01205         <span class="keywordflow">for</span> cred <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a033b5599dc21cdd04ad0e7db9d5b9890">credentials</a>.iter(host):
<a name="l01206"></a>01206             <span class="keywordflow">for</span> scheme <span class="keywordflow">in</span> AUTH_SCHEME_ORDER:
<a name="l01207"></a>01207                 <span class="keywordflow">if</span> challenges.has_key(scheme):
<a name="l01208"></a>01208                     <span class="keywordflow">yield</span> AUTH_SCHEME_CLASSES[scheme](cred, host, request_uri, headers, response, content, self)
<a name="l01209"></a>01209 
<a name="l01210"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ac6baeccfcfaea7f0b3c2c4fa9674ab45">01210</a>     <span class="keyword">def </span>add_credentials(self, name, password, domain=&quot;&quot;):
<a name="l01211"></a>01211         <span class="stringliteral">&quot;&quot;&quot;Add a name and password that will be used</span>
<a name="l01212"></a>01212 <span class="stringliteral">        any time a request requires authentication.&quot;&quot;&quot;</span>
<a name="l01213"></a>01213         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a033b5599dc21cdd04ad0e7db9d5b9890">credentials</a>.add(name, password, domain)
<a name="l01214"></a>01214 
<a name="l01215"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a3d2e2704363c73af78a1e67f7374db0f">01215</a>     <span class="keyword">def </span>add_certificate(self, key, cert, domain):
<a name="l01216"></a>01216         <span class="stringliteral">&quot;&quot;&quot;Add a key and cert that will be used</span>
<a name="l01217"></a>01217 <span class="stringliteral">        any time a request requires authentication.&quot;&quot;&quot;</span>
<a name="l01218"></a>01218         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#afe75200efff6d8f13efca6400b46f071">certificates</a>.add(key, cert, domain)
<a name="l01219"></a>01219 
<a name="l01220"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aeecd1a7d8a81017831b330a20d805f63">01220</a>     <span class="keyword">def </span>clear_credentials(self):
<a name="l01221"></a>01221         <span class="stringliteral">&quot;&quot;&quot;Remove all the names and passwords</span>
<a name="l01222"></a>01222 <span class="stringliteral">        that are used for authentication&quot;&quot;&quot;</span>
<a name="l01223"></a>01223         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a033b5599dc21cdd04ad0e7db9d5b9890">credentials</a>.clear()
<a name="l01224"></a>01224         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a5e76c7ec1c3c4261a10e29b4ee3e1923">authorizations</a> = []
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     <span class="keyword">def </span>_conn_request(self, conn, request_uri, method, body, headers):
<a name="l01227"></a>01227         <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(2):
<a name="l01228"></a>01228             <span class="keywordflow">try</span>:
<a name="l01229"></a>01229                 <span class="keywordflow">if</span> conn.sock <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01230"></a>01230                   conn.connect()
<a name="l01231"></a>01231                 conn.request(method, request_uri, body, headers)
<a name="l01232"></a>01232             <span class="keywordflow">except</span> socket.timeout:
<a name="l01233"></a>01233                 <span class="keywordflow">raise</span>
<a name="l01234"></a>01234             <span class="keywordflow">except</span> socket.gaierror:
<a name="l01235"></a>01235                 conn.close()
<a name="l01236"></a>01236                 <span class="keywordflow">raise</span> ServerNotFoundError(<span class="stringliteral">&quot;Unable to find the server at %s&quot;</span> % conn.host)
<a name="l01237"></a>01237             <span class="keywordflow">except</span> ssl_SSLError:
<a name="l01238"></a>01238                 conn.close()
<a name="l01239"></a>01239                 <span class="keywordflow">raise</span>
<a name="l01240"></a>01240             <span class="keywordflow">except</span> socket.error, e:
<a name="l01241"></a>01241                 err = 0
<a name="l01242"></a>01242                 <span class="keywordflow">if</span> hasattr(e, <span class="stringliteral">&#39;args&#39;</span>):
<a name="l01243"></a>01243                     err = getattr(e, <span class="stringliteral">&#39;args&#39;</span>)[0]
<a name="l01244"></a>01244                 <span class="keywordflow">else</span>:
<a name="l01245"></a>01245                     err = e.errno
<a name="l01246"></a>01246                 <span class="keywordflow">if</span> err == errno.ECONNREFUSED: <span class="comment"># Connection refused</span>
<a name="l01247"></a>01247                     <span class="keywordflow">raise</span>
<a name="l01248"></a>01248             <span class="keywordflow">except</span> httplib.HTTPException:
<a name="l01249"></a>01249                 <span class="comment"># Just because the server closed the connection doesn&#39;t apparently mean</span>
<a name="l01250"></a>01250                 <span class="comment"># that the server didn&#39;t send a response.</span>
<a name="l01251"></a>01251                 <span class="keywordflow">if</span> conn.sock <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01252"></a>01252                     <span class="keywordflow">if</span> i == 0:
<a name="l01253"></a>01253                         conn.close()
<a name="l01254"></a>01254                         conn.connect()
<a name="l01255"></a>01255                         <span class="keywordflow">continue</span>
<a name="l01256"></a>01256                     <span class="keywordflow">else</span>:
<a name="l01257"></a>01257                         conn.close()
<a name="l01258"></a>01258                         <span class="keywordflow">raise</span>
<a name="l01259"></a>01259                 <span class="keywordflow">if</span> i == 0:
<a name="l01260"></a>01260                     conn.close()
<a name="l01261"></a>01261                     conn.connect()
<a name="l01262"></a>01262                     <span class="keywordflow">continue</span>
<a name="l01263"></a>01263             <span class="keywordflow">try</span>:
<a name="l01264"></a>01264                 response = conn.getresponse()
<a name="l01265"></a>01265             <span class="keywordflow">except</span> (socket.error, httplib.HTTPException):
<a name="l01266"></a>01266                 <span class="keywordflow">if</span> i == 0:
<a name="l01267"></a>01267                     conn.close()
<a name="l01268"></a>01268                     conn.connect()
<a name="l01269"></a>01269                     <span class="keywordflow">continue</span>
<a name="l01270"></a>01270                 <span class="keywordflow">else</span>:
<a name="l01271"></a>01271                     <span class="keywordflow">raise</span>
<a name="l01272"></a>01272             <span class="keywordflow">else</span>:
<a name="l01273"></a>01273                 content = <span class="stringliteral">&quot;&quot;</span>
<a name="l01274"></a>01274                 <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;HEAD&quot;</span>:
<a name="l01275"></a>01275                     response.close()
<a name="l01276"></a>01276                 <span class="keywordflow">else</span>:
<a name="l01277"></a>01277                     content = response.read()
<a name="l01278"></a>01278                 response = Response(response)
<a name="l01279"></a>01279                 <span class="keywordflow">if</span> method != <span class="stringliteral">&quot;HEAD&quot;</span>:
<a name="l01280"></a>01280                     content = _decompressContent(response, content)
<a name="l01281"></a>01281             <span class="keywordflow">break</span>
<a name="l01282"></a>01282         <span class="keywordflow">return</span> (response, content)
<a name="l01283"></a>01283 
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="keyword">def </span>_request(self, conn, host, absolute_uri, request_uri, method, body, headers, redirections, cachekey):
<a name="l01286"></a>01286         <span class="stringliteral">&quot;&quot;&quot;Do the actual request using the connection object</span>
<a name="l01287"></a>01287 <span class="stringliteral">        and also follow one level of redirects if necessary&quot;&quot;&quot;</span>
<a name="l01288"></a>01288 
<a name="l01289"></a>01289         auths = [(auth.depth(request_uri), auth) <span class="keywordflow">for</span> auth <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a5e76c7ec1c3c4261a10e29b4ee3e1923">authorizations</a> <span class="keywordflow">if</span> auth.inscope(host, request_uri)]
<a name="l01290"></a>01290         auth = auths <span class="keywordflow">and</span> sorted(auths)[0][1] <span class="keywordflow">or</span> <span class="keywordtype">None</span>
<a name="l01291"></a>01291         <span class="keywordflow">if</span> auth:
<a name="l01292"></a>01292             auth.request(method, request_uri, headers, body)
<a name="l01293"></a>01293 
<a name="l01294"></a>01294         (response, content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#abc9fda14f5a9723dda44594722687861">_conn_request</a>(conn, request_uri, method, body, headers)
<a name="l01295"></a>01295 
<a name="l01296"></a>01296         <span class="keywordflow">if</span> auth:
<a name="l01297"></a>01297             <span class="keywordflow">if</span> auth.response(response, body):
<a name="l01298"></a>01298                 auth.request(method, request_uri, headers, body)
<a name="l01299"></a>01299                 (response, content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#abc9fda14f5a9723dda44594722687861">_conn_request</a>(conn, request_uri, method, body, headers )
<a name="l01300"></a>01300                 response._stale_digest = 1
<a name="l01301"></a>01301 
<a name="l01302"></a>01302         <span class="keywordflow">if</span> response.status == 401:
<a name="l01303"></a>01303             <span class="keywordflow">for</span> authorization <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#acd6c7635992f3ffbfec31e33f5e1d448">_auth_from_challenge</a>(host, request_uri, headers, response, content):
<a name="l01304"></a>01304                 authorization.request(method, request_uri, headers, body)
<a name="l01305"></a>01305                 (response, content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#abc9fda14f5a9723dda44594722687861">_conn_request</a>(conn, request_uri, method, body, headers, )
<a name="l01306"></a>01306                 <span class="keywordflow">if</span> response.status != 401:
<a name="l01307"></a>01307                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a5e76c7ec1c3c4261a10e29b4ee3e1923">authorizations</a>.append(authorization)
<a name="l01308"></a>01308                     authorization.response(response, body)
<a name="l01309"></a>01309                     <span class="keywordflow">break</span>
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="keywordflow">if</span> (self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a8fa11f25b3c8f9036e07abdbdca9d355">follow_all_redirects</a> <span class="keywordflow">or</span> (method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;HEAD&quot;</span>]) <span class="keywordflow">or</span> response.status == 303):
<a name="l01312"></a>01312             <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a1c9ba7f285fa007ae0e566dfa1393c59">follow_redirects</a> <span class="keywordflow">and</span> response.status <span class="keywordflow">in</span> [300, 301, 302, 303, 307]:
<a name="l01313"></a>01313                 <span class="comment"># Pick out the location header and basically start from the beginning</span>
<a name="l01314"></a>01314                 <span class="comment"># remembering first to strip the ETag header and decrement our &#39;depth&#39;</span>
<a name="l01315"></a>01315                 <span class="keywordflow">if</span> redirections:
<a name="l01316"></a>01316                     <span class="keywordflow">if</span> <span class="keywordflow">not</span> response.has_key(<span class="stringliteral">&#39;location&#39;</span>) <span class="keywordflow">and</span> response.status != 300:
<a name="l01317"></a>01317                         <span class="keywordflow">raise</span> RedirectMissingLocation( _(<span class="stringliteral">&quot;Redirected but the response is missing a Location: header.&quot;</span>), response, content)
<a name="l01318"></a>01318                     <span class="comment"># Fix-up relative redirects (which violate an RFC 2616 MUST)</span>
<a name="l01319"></a>01319                     <span class="keywordflow">if</span> response.has_key(<span class="stringliteral">&#39;location&#39;</span>):
<a name="l01320"></a>01320                         location = response[<span class="stringliteral">&#39;location&#39;</span>]
<a name="l01321"></a>01321                         (scheme, authority, path, query, fragment) = parse_uri(location)
<a name="l01322"></a>01322                         <span class="keywordflow">if</span> authority == <span class="keywordtype">None</span>:
<a name="l01323"></a>01323                             response[<span class="stringliteral">&#39;location&#39;</span>] = urlparse.urljoin(absolute_uri, location)
<a name="l01324"></a>01324                     <span class="keywordflow">if</span> response.status == 301 <span class="keywordflow">and</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;HEAD&quot;</span>]:
<a name="l01325"></a>01325                         response[<span class="stringliteral">&#39;-x-permanent-redirect-url&#39;</span>] = response[<span class="stringliteral">&#39;location&#39;</span>]
<a name="l01326"></a>01326                         <span class="keywordflow">if</span> <span class="keywordflow">not</span> response.has_key(<span class="stringliteral">&#39;content-location&#39;</span>):
<a name="l01327"></a>01327                             response[<span class="stringliteral">&#39;content-location&#39;</span>] = absolute_uri
<a name="l01328"></a>01328                         _updateCache(headers, response, content, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>, cachekey)
<a name="l01329"></a>01329                     <span class="keywordflow">if</span> headers.has_key(<span class="stringliteral">&#39;if-none-match&#39;</span>):
<a name="l01330"></a>01330                         del headers[<span class="stringliteral">&#39;if-none-match&#39;</span>]
<a name="l01331"></a>01331                     <span class="keywordflow">if</span> headers.has_key(<span class="stringliteral">&#39;if-modified-since&#39;</span>):
<a name="l01332"></a>01332                         del headers[<span class="stringliteral">&#39;if-modified-since&#39;</span>]
<a name="l01333"></a>01333                     <span class="keywordflow">if</span> response.has_key(<span class="stringliteral">&#39;location&#39;</span>):
<a name="l01334"></a>01334                         location = response[<span class="stringliteral">&#39;location&#39;</span>]
<a name="l01335"></a>01335                         old_response = copy.deepcopy(response)
<a name="l01336"></a>01336                         <span class="keywordflow">if</span> <span class="keywordflow">not</span> old_response.has_key(<span class="stringliteral">&#39;content-location&#39;</span>):
<a name="l01337"></a>01337                             old_response[<span class="stringliteral">&#39;content-location&#39;</span>] = absolute_uri
<a name="l01338"></a>01338                         redirect_method = method
<a name="l01339"></a>01339                         <span class="keywordflow">if</span> response.status <span class="keywordflow">in</span> [302, 303]:
<a name="l01340"></a>01340                             redirect_method = <span class="stringliteral">&quot;GET&quot;</span>
<a name="l01341"></a>01341                             body = <span class="keywordtype">None</span>
<a name="l01342"></a>01342                         (response, content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ab5b495051200fc78c1849920d4ec66c7">request</a>(location, redirect_method, body=body, headers = headers, redirections = redirections - 1)
<a name="l01343"></a>01343                         response.previous = old_response
<a name="l01344"></a>01344                 <span class="keywordflow">else</span>:
<a name="l01345"></a>01345                     <span class="keywordflow">raise</span> RedirectLimit(<span class="stringliteral">&quot;Redirected more times than rediection_limit allows.&quot;</span>, response, content)
<a name="l01346"></a>01346             <span class="keywordflow">elif</span> response.status <span class="keywordflow">in</span> [200, 203] <span class="keywordflow">and</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;HEAD&quot;</span>]:
<a name="l01347"></a>01347                 <span class="comment"># Don&#39;t cache 206&#39;s since we aren&#39;t going to handle byte range requests</span>
<a name="l01348"></a>01348                 <span class="keywordflow">if</span> <span class="keywordflow">not</span> response.has_key(<span class="stringliteral">&#39;content-location&#39;</span>):
<a name="l01349"></a>01349                     response[<span class="stringliteral">&#39;content-location&#39;</span>] = absolute_uri
<a name="l01350"></a>01350                 _updateCache(headers, response, content, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>, cachekey)
<a name="l01351"></a>01351 
<a name="l01352"></a>01352         <span class="keywordflow">return</span> (response, content)
<a name="l01353"></a>01353 
<a name="l01354"></a>01354     <span class="keyword">def </span>_normalize_headers(self, headers):
<a name="l01355"></a>01355         <span class="keywordflow">return</span> _normalize_headers(headers)
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 <span class="comment"># Need to catch and rebrand some exceptions</span>
<a name="l01358"></a>01358 <span class="comment"># Then need to optionally turn all exceptions into status codes</span>
<a name="l01359"></a>01359 <span class="comment"># including all socket.* and httplib.* exceptions.</span>
<a name="l01360"></a>01360 
<a name="l01361"></a>01361 
<a name="l01362"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ab5b495051200fc78c1849920d4ec66c7">01362</a>     <span class="keyword">def </span>request(self, uri, method=&quot;GET&quot;, body=None, headers=None, redirections=DEFAULT_MAX_REDIRECTS, connection_type=None):
<a name="l01363"></a>01363         <span class="stringliteral">&quot;&quot;&quot; Performs a single HTTP request.</span>
<a name="l01364"></a>01364 <span class="stringliteral">The &#39;uri&#39; is the URI of the HTTP resource and can begin</span>
<a name="l01365"></a>01365 <span class="stringliteral">with either &#39;http&#39; or &#39;https&#39;. The value of &#39;uri&#39; must be an absolute URI.</span>
<a name="l01366"></a>01366 <span class="stringliteral"></span>
<a name="l01367"></a>01367 <span class="stringliteral">The &#39;method&#39; is the HTTP method to perform, such as GET, POST, DELETE, etc.</span>
<a name="l01368"></a>01368 <span class="stringliteral">There is no restriction on the methods allowed.</span>
<a name="l01369"></a>01369 <span class="stringliteral"></span>
<a name="l01370"></a>01370 <span class="stringliteral">The &#39;body&#39; is the entity body to be sent with the request. It is a string</span>
<a name="l01371"></a>01371 <span class="stringliteral">object.</span>
<a name="l01372"></a>01372 <span class="stringliteral"></span>
<a name="l01373"></a>01373 <span class="stringliteral">Any extra headers that are to be sent with the request should be provided in the</span>
<a name="l01374"></a>01374 <span class="stringliteral">&#39;headers&#39; dictionary.</span>
<a name="l01375"></a>01375 <span class="stringliteral"></span>
<a name="l01376"></a>01376 <span class="stringliteral">The maximum number of redirect to follow before raising an</span>
<a name="l01377"></a>01377 <span class="stringliteral">exception is &#39;redirections. The default is 5.</span>
<a name="l01378"></a>01378 <span class="stringliteral"></span>
<a name="l01379"></a>01379 <span class="stringliteral">The return value is a tuple of (response, content), the first</span>
<a name="l01380"></a>01380 <span class="stringliteral">being and instance of the &#39;Response&#39; class, the second being</span>
<a name="l01381"></a>01381 <span class="stringliteral">a string that contains the response entity body.</span>
<a name="l01382"></a>01382 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01383"></a>01383         <span class="keywordflow">try</span>:
<a name="l01384"></a>01384             <span class="keywordflow">if</span> headers <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01385"></a>01385                 headers = {}
<a name="l01386"></a>01386             <span class="keywordflow">else</span>:
<a name="l01387"></a>01387                 headers = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a680eb33a402980220eaae61ea13e375b">_normalize_headers</a>(headers)
<a name="l01388"></a>01388 
<a name="l01389"></a>01389             <span class="keywordflow">if</span> <span class="keywordflow">not</span> headers.has_key(<span class="stringliteral">&#39;user-agent&#39;</span>):
<a name="l01390"></a>01390                 headers[<span class="stringliteral">&#39;user-agent&#39;</span>] = <span class="stringliteral">&quot;Python-httplib2/%s (gzip)&quot;</span> % __version__
<a name="l01391"></a>01391 
<a name="l01392"></a>01392             uri = iri2uri(uri)
<a name="l01393"></a>01393 
<a name="l01394"></a>01394             (scheme, authority, request_uri, defrag_uri) = urlnorm(uri)
<a name="l01395"></a>01395             domain_port = authority.split(<span class="stringliteral">&quot;:&quot;</span>)[0:2]
<a name="l01396"></a>01396             <span class="keywordflow">if</span> len(domain_port) == 2 <span class="keywordflow">and</span> domain_port[1] == <span class="stringliteral">&#39;443&#39;</span> <span class="keywordflow">and</span> scheme == <span class="stringliteral">&#39;http&#39;</span>:
<a name="l01397"></a>01397                 scheme = <span class="stringliteral">&#39;https&#39;</span>
<a name="l01398"></a>01398                 authority = domain_port[0]
<a name="l01399"></a>01399 
<a name="l01400"></a>01400             proxy_info = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a6ab5f27f876fd403ce438c1d897b2ae3">_get_proxy_info</a>(scheme, authority)
<a name="l01401"></a>01401 
<a name="l01402"></a>01402             conn_key = scheme+<span class="stringliteral">&quot;:&quot;</span>+authority
<a name="l01403"></a>01403             <span class="keywordflow">if</span> conn_key <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aebc22aef6735e295dfcc8a670228e0bf">connections</a>:
<a name="l01404"></a>01404                 conn = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aebc22aef6735e295dfcc8a670228e0bf">connections</a>[conn_key]
<a name="l01405"></a>01405             <span class="keywordflow">else</span>:
<a name="l01406"></a>01406                 <span class="keywordflow">if</span> <span class="keywordflow">not</span> connection_type:
<a name="l01407"></a>01407                   connection_type = SCHEME_TO_CONNECTION[scheme]
<a name="l01408"></a>01408                 certs = list(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#afe75200efff6d8f13efca6400b46f071">certificates</a>.iter(authority))
<a name="l01409"></a>01409                 <span class="keywordflow">if</span> issubclass(connection_type, HTTPSConnectionWithTimeout):
<a name="l01410"></a>01410                     <span class="keywordflow">if</span> certs:
<a name="l01411"></a>01411                         conn = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aebc22aef6735e295dfcc8a670228e0bf">connections</a>[conn_key] = connection_type(
<a name="l01412"></a>01412                                 authority, key_file=certs[0][0],
<a name="l01413"></a>01413                                 cert_file=certs[0][1], timeout=self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aa5769edb4b915ce0fb3b652501ec3a0d">timeout</a>,
<a name="l01414"></a>01414                                 proxy_info=proxy_info,
<a name="l01415"></a>01415                                 ca_certs=self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ac1a290abe26c3ce80aca21dcc54814b8">ca_certs</a>,
<a name="l01416"></a>01416                                 disable_ssl_certificate_validation=
<a name="l01417"></a>01417                                         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ab153c992218f0e7e9d4bf7c8a332913c">disable_ssl_certificate_validation</a>)
<a name="l01418"></a>01418                     <span class="keywordflow">else</span>:
<a name="l01419"></a>01419                         conn = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aebc22aef6735e295dfcc8a670228e0bf">connections</a>[conn_key] = connection_type(
<a name="l01420"></a>01420                                 authority, timeout=self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aa5769edb4b915ce0fb3b652501ec3a0d">timeout</a>,
<a name="l01421"></a>01421                                 proxy_info=proxy_info,
<a name="l01422"></a>01422                                 ca_certs=self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ac1a290abe26c3ce80aca21dcc54814b8">ca_certs</a>,
<a name="l01423"></a>01423                                 disable_ssl_certificate_validation=
<a name="l01424"></a>01424                                         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ab153c992218f0e7e9d4bf7c8a332913c">disable_ssl_certificate_validation</a>)
<a name="l01425"></a>01425                 <span class="keywordflow">else</span>:
<a name="l01426"></a>01426                     conn = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aebc22aef6735e295dfcc8a670228e0bf">connections</a>[conn_key] = connection_type(
<a name="l01427"></a>01427                             authority, timeout=self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aa5769edb4b915ce0fb3b652501ec3a0d">timeout</a>,
<a name="l01428"></a>01428                             proxy_info=proxy_info)
<a name="l01429"></a>01429                 conn.set_debuglevel(debuglevel)
<a name="l01430"></a>01430 
<a name="l01431"></a>01431             <span class="keywordflow">if</span> <span class="stringliteral">&#39;range&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> headers <span class="keywordflow">and</span> <span class="stringliteral">&#39;accept-encoding&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> headers:
<a name="l01432"></a>01432                 headers[<span class="stringliteral">&#39;accept-encoding&#39;</span>] = <span class="stringliteral">&#39;gzip, deflate&#39;</span>
<a name="l01433"></a>01433 
<a name="l01434"></a>01434             info = email.Message.Message()
<a name="l01435"></a>01435             cached_value = <span class="keywordtype">None</span>
<a name="l01436"></a>01436             <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>:
<a name="l01437"></a>01437                 cachekey = defrag_uri
<a name="l01438"></a>01438                 cached_value = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>.get(cachekey)
<a name="l01439"></a>01439                 <span class="keywordflow">if</span> cached_value:
<a name="l01440"></a>01440                     <span class="comment"># info = email.message_from_string(cached_value)</span>
<a name="l01441"></a>01441                     <span class="comment">#</span>
<a name="l01442"></a>01442                     <span class="comment"># Need to replace the line above with the kludge below</span>
<a name="l01443"></a>01443                     <span class="comment"># to fix the non-existent bug not fixed in this</span>
<a name="l01444"></a>01444                     <span class="comment"># bug report: http://mail.python.org/pipermail/python-bugs-list/2005-September/030289.html</span>
<a name="l01445"></a>01445                     <span class="keywordflow">try</span>:
<a name="l01446"></a>01446                         info, content = cached_value.split(<span class="stringliteral">&#39;\r\n\r\n&#39;</span>, 1)
<a name="l01447"></a>01447                         feedparser = email.FeedParser.FeedParser()
<a name="l01448"></a>01448                         feedparser.feed(info)
<a name="l01449"></a>01449                         info = feedparser.close()
<a name="l01450"></a>01450                         feedparser._parse = <span class="keywordtype">None</span>
<a name="l01451"></a>01451                     <span class="keywordflow">except</span> IndexError:
<a name="l01452"></a>01452                         self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>.delete(cachekey)
<a name="l01453"></a>01453                         cachekey = <span class="keywordtype">None</span>
<a name="l01454"></a>01454                         cached_value = <span class="keywordtype">None</span>
<a name="l01455"></a>01455             <span class="keywordflow">else</span>:
<a name="l01456"></a>01456                 cachekey = <span class="keywordtype">None</span>
<a name="l01457"></a>01457 
<a name="l01458"></a>01458             <span class="keywordflow">if</span> method <span class="keywordflow">in</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a4bd045145f8ee8f348ddd8c5c89e4231">optimistic_concurrency_methods</a> <span class="keywordflow">and</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a> <span class="keywordflow">and</span> info.has_key(<span class="stringliteral">&#39;etag&#39;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#acb5a36a64ccc7e47b76de6276aa452f2">ignore_etag</a> <span class="keywordflow">and</span> <span class="stringliteral">&#39;if-match&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> headers:
<a name="l01459"></a>01459                 <span class="comment"># http://www.w3.org/1999/04/Editing/</span>
<a name="l01460"></a>01460                 headers[<span class="stringliteral">&#39;if-match&#39;</span>] = info[<span class="stringliteral">&#39;etag&#39;</span>]
<a name="l01461"></a>01461 
<a name="l01462"></a>01462             <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;HEAD&quot;</span>] <span class="keywordflow">and</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a> <span class="keywordflow">and</span> cachekey:
<a name="l01463"></a>01463                 <span class="comment"># RFC 2616 Section 13.10</span>
<a name="l01464"></a>01464                 self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>.delete(cachekey)
<a name="l01465"></a>01465 
<a name="l01466"></a>01466             <span class="comment"># Check the vary header in the cache to see if this request</span>
<a name="l01467"></a>01467             <span class="comment"># matches what varies in the cache.</span>
<a name="l01468"></a>01468             <span class="keywordflow">if</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&#39;GET&#39;</span>, <span class="stringliteral">&#39;HEAD&#39;</span>] <span class="keywordflow">and</span> <span class="stringliteral">&#39;vary&#39;</span> <span class="keywordflow">in</span> info:
<a name="l01469"></a>01469                 vary = info[<span class="stringliteral">&#39;vary&#39;</span>]
<a name="l01470"></a>01470                 vary_headers = vary.lower().replace(<span class="stringliteral">&#39; &#39;</span>, <span class="stringliteral">&#39;&#39;</span>).split(<span class="stringliteral">&#39;,&#39;</span>)
<a name="l01471"></a>01471                 <span class="keywordflow">for</span> header <span class="keywordflow">in</span> vary_headers:
<a name="l01472"></a>01472                     key = <span class="stringliteral">&#39;-varied-%s&#39;</span> % header
<a name="l01473"></a>01473                     value = info[key]
<a name="l01474"></a>01474                     <span class="keywordflow">if</span> headers.get(header, <span class="keywordtype">None</span>) != value:
<a name="l01475"></a>01475                             cached_value = <span class="keywordtype">None</span>
<a name="l01476"></a>01476                             <span class="keywordflow">break</span>
<a name="l01477"></a>01477 
<a name="l01478"></a>01478             <span class="keywordflow">if</span> cached_value <span class="keywordflow">and</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;HEAD&quot;</span>] <span class="keywordflow">and</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a> <span class="keywordflow">and</span> <span class="stringliteral">&#39;range&#39;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> headers:
<a name="l01479"></a>01479                 <span class="keywordflow">if</span> info.has_key(<span class="stringliteral">&#39;-x-permanent-redirect-url&#39;</span>):
<a name="l01480"></a>01480                     <span class="comment"># Should cached permanent redirects be counted in our redirection count? For now, yes.</span>
<a name="l01481"></a>01481                     <span class="keywordflow">if</span> redirections &lt;= 0:
<a name="l01482"></a>01482                       <span class="keywordflow">raise</span> RedirectLimit(<span class="stringliteral">&quot;Redirected more times than rediection_limit allows.&quot;</span>, {}, <span class="stringliteral">&quot;&quot;</span>)
<a name="l01483"></a>01483                     (response, new_content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#ab5b495051200fc78c1849920d4ec66c7">request</a>(info[<span class="stringliteral">&#39;-x-permanent-redirect-url&#39;</span>], <span class="stringliteral">&quot;GET&quot;</span>, headers = headers, redirections = redirections - 1)
<a name="l01484"></a>01484                     response.previous = Response(info)
<a name="l01485"></a>01485                     response.previous.fromcache = <span class="keyword">True</span>
<a name="l01486"></a>01486                 <span class="keywordflow">else</span>:
<a name="l01487"></a>01487                     <span class="comment"># Determine our course of action:</span>
<a name="l01488"></a>01488                     <span class="comment">#   Is the cached entry fresh or stale?</span>
<a name="l01489"></a>01489                     <span class="comment">#   Has the client requested a non-cached response?</span>
<a name="l01490"></a>01490                     <span class="comment">#</span>
<a name="l01491"></a>01491                     <span class="comment"># There seems to be three possible answers:</span>
<a name="l01492"></a>01492                     <span class="comment"># 1. [FRESH] Return the cache entry w/o doing a GET</span>
<a name="l01493"></a>01493                     <span class="comment"># 2. [STALE] Do the GET (but add in cache validators if available)</span>
<a name="l01494"></a>01494                     <span class="comment"># 3. [TRANSPARENT] Do a GET w/o any cache validators (Cache-Control: no-cache) on the request</span>
<a name="l01495"></a>01495                     entry_disposition = _entry_disposition(info, headers)
<a name="l01496"></a>01496 
<a name="l01497"></a>01497                     <span class="keywordflow">if</span> entry_disposition == <span class="stringliteral">&quot;FRESH&quot;</span>:
<a name="l01498"></a>01498                         <span class="keywordflow">if</span> <span class="keywordflow">not</span> cached_value:
<a name="l01499"></a>01499                             info[<span class="stringliteral">&#39;status&#39;</span>] = <span class="stringliteral">&#39;504&#39;</span>
<a name="l01500"></a>01500                             content = <span class="stringliteral">&quot;&quot;</span>
<a name="l01501"></a>01501                         response = Response(info)
<a name="l01502"></a>01502                         <span class="keywordflow">if</span> cached_value:
<a name="l01503"></a>01503                             response.fromcache = <span class="keyword">True</span>
<a name="l01504"></a>01504                         <span class="keywordflow">return</span> (response, content)
<a name="l01505"></a>01505 
<a name="l01506"></a>01506                     <span class="keywordflow">if</span> entry_disposition == <span class="stringliteral">&quot;STALE&quot;</span>:
<a name="l01507"></a>01507                         <span class="keywordflow">if</span> info.has_key(<span class="stringliteral">&#39;etag&#39;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#acb5a36a64ccc7e47b76de6276aa452f2">ignore_etag</a> <span class="keywordflow">and</span> <span class="keywordflow">not</span> <span class="stringliteral">&#39;if-none-match&#39;</span> <span class="keywordflow">in</span> headers:
<a name="l01508"></a>01508                             headers[<span class="stringliteral">&#39;if-none-match&#39;</span>] = info[<span class="stringliteral">&#39;etag&#39;</span>]
<a name="l01509"></a>01509                         <span class="keywordflow">if</span> info.has_key(<span class="stringliteral">&#39;last-modified&#39;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> <span class="stringliteral">&#39;last-modified&#39;</span> <span class="keywordflow">in</span> headers:
<a name="l01510"></a>01510                             headers[<span class="stringliteral">&#39;if-modified-since&#39;</span>] = info[<span class="stringliteral">&#39;last-modified&#39;</span>]
<a name="l01511"></a>01511                     <span class="keywordflow">elif</span> entry_disposition == <span class="stringliteral">&quot;TRANSPARENT&quot;</span>:
<a name="l01512"></a>01512                         <span class="keywordflow">pass</span>
<a name="l01513"></a>01513 
<a name="l01514"></a>01514                     (response, new_content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aea51b4f2cc3a09afa2e2e40d343109ca">_request</a>(conn, authority, uri, request_uri, method, body, headers, redirections, cachekey)
<a name="l01515"></a>01515 
<a name="l01516"></a>01516                 <span class="keywordflow">if</span> response.status == 304 <span class="keywordflow">and</span> method == <span class="stringliteral">&quot;GET&quot;</span>:
<a name="l01517"></a>01517                     <span class="comment"># Rewrite the cache entry with the new end-to-end headers</span>
<a name="l01518"></a>01518                     <span class="comment"># Take all headers that are in response</span>
<a name="l01519"></a>01519                     <span class="comment"># and overwrite their values in info.</span>
<a name="l01520"></a>01520                     <span class="comment"># unless they are hop-by-hop, or are listed in the connection header.</span>
<a name="l01521"></a>01521 
<a name="l01522"></a>01522                     <span class="keywordflow">for</span> key <span class="keywordflow">in</span> _get_end2end_headers(response):
<a name="l01523"></a>01523                         info[key] = response[key]
<a name="l01524"></a>01524                     merged_response = Response(info)
<a name="l01525"></a>01525                     <span class="keywordflow">if</span> hasattr(response, <span class="stringliteral">&quot;_stale_digest&quot;</span>):
<a name="l01526"></a>01526                         merged_response._stale_digest = response._stale_digest
<a name="l01527"></a>01527                     _updateCache(headers, merged_response, content, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>, cachekey)
<a name="l01528"></a>01528                     response = merged_response
<a name="l01529"></a>01529                     response.status = 200
<a name="l01530"></a>01530                     response.fromcache = <span class="keyword">True</span>
<a name="l01531"></a>01531 
<a name="l01532"></a>01532                 <span class="keywordflow">elif</span> response.status == 200:
<a name="l01533"></a>01533                     content = new_content
<a name="l01534"></a>01534                 <span class="keywordflow">else</span>:
<a name="l01535"></a>01535                     self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a2fbf2ce1e2e3e5e90b49facf62d3e953">cache</a>.delete(cachekey)
<a name="l01536"></a>01536                     content = new_content
<a name="l01537"></a>01537             <span class="keywordflow">else</span>:
<a name="l01538"></a>01538                 cc = _parse_cache_control(headers)
<a name="l01539"></a>01539                 <span class="keywordflow">if</span> cc.has_key(<span class="stringliteral">&#39;only-if-cached&#39;</span>):
<a name="l01540"></a>01540                     info[<span class="stringliteral">&#39;status&#39;</span>] = <span class="stringliteral">&#39;504&#39;</span>
<a name="l01541"></a>01541                     response = Response(info)
<a name="l01542"></a>01542                     content = <span class="stringliteral">&quot;&quot;</span>
<a name="l01543"></a>01543                 <span class="keywordflow">else</span>:
<a name="l01544"></a>01544                     (response, content) = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#aea51b4f2cc3a09afa2e2e40d343109ca">_request</a>(conn, authority, uri, request_uri, method, body, headers, redirections, cachekey)
<a name="l01545"></a>01545         <span class="keywordflow">except</span> Exception, e:
<a name="l01546"></a>01546             <span class="keywordflow">if</span> self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#a4467a06f9145e1a71173d6207f7d5359">force_exception_to_status_code</a>:
<a name="l01547"></a>01547                 <span class="keywordflow">if</span> isinstance(e, HttpLib2ErrorWithResponse):
<a name="l01548"></a>01548                     response = e.response
<a name="l01549"></a>01549                     content = e.content
<a name="l01550"></a>01550                     response.status = 500
<a name="l01551"></a>01551                     response.reason = str(e)
<a name="l01552"></a>01552                 <span class="keywordflow">elif</span> isinstance(e, socket.timeout):
<a name="l01553"></a>01553                     content = <span class="stringliteral">&quot;Request Timeout&quot;</span>
<a name="l01554"></a>01554                     response = Response( {
<a name="l01555"></a>01555                             <span class="stringliteral">&quot;content-type&quot;</span>: <span class="stringliteral">&quot;text/plain&quot;</span>,
<a name="l01556"></a>01556                             <span class="stringliteral">&quot;status&quot;</span>: <span class="stringliteral">&quot;408&quot;</span>,
<a name="l01557"></a>01557                             <span class="stringliteral">&quot;content-length&quot;</span>: len(content)
<a name="l01558"></a>01558                             })
<a name="l01559"></a>01559                     response.reason = <span class="stringliteral">&quot;Request Timeout&quot;</span>
<a name="l01560"></a>01560                 <span class="keywordflow">else</span>:
<a name="l01561"></a>01561                     content = str(e)
<a name="l01562"></a>01562                     response = Response( {
<a name="l01563"></a>01563                             <span class="stringliteral">&quot;content-type&quot;</span>: <span class="stringliteral">&quot;text/plain&quot;</span>,
<a name="l01564"></a>01564                             <span class="stringliteral">&quot;status&quot;</span>: <span class="stringliteral">&quot;400&quot;</span>,
<a name="l01565"></a>01565                             <span class="stringliteral">&quot;content-length&quot;</span>: len(content)
<a name="l01566"></a>01566                             })
<a name="l01567"></a>01567                     response.reason = <span class="stringliteral">&quot;Bad Request&quot;</span>
<a name="l01568"></a>01568             <span class="keywordflow">else</span>:
<a name="l01569"></a>01569                 <span class="keywordflow">raise</span>
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 
<a name="l01572"></a>01572         <span class="keywordflow">return</span> (response, content)
<a name="l01573"></a>01573 
<a name="l01574"></a>01574     <span class="keyword">def </span>_get_proxy_info(self, scheme, authority):
<a name="l01575"></a>01575         <span class="stringliteral">&quot;&quot;&quot;Return a ProxyInfo instance (or None) based on the scheme</span>
<a name="l01576"></a>01576 <span class="stringliteral">        and authority.</span>
<a name="l01577"></a>01577 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01578"></a>01578         hostname, port = urllib.splitport(authority)
<a name="l01579"></a>01579         proxy_info = self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Http.html#abcb995a725a6ad00939745934050582a">proxy_info</a>
<a name="l01580"></a>01580         <span class="keywordflow">if</span> callable(proxy_info):
<a name="l01581"></a>01581             proxy_info = proxy_info(scheme)
<a name="l01582"></a>01582 
<a name="l01583"></a>01583         <span class="keywordflow">if</span> (hasattr(proxy_info, <span class="stringliteral">&#39;applies_to&#39;</span>)
<a name="l01584"></a>01584             <span class="keywordflow">and</span> <span class="keywordflow">not</span> proxy_info.applies_to(hostname)):
<a name="l01585"></a>01585             proxy_info = <span class="keywordtype">None</span>
<a name="l01586"></a>01586         <span class="keywordflow">return</span> proxy_info
<a name="l01587"></a>01587 
<a name="l01588"></a>01588 
<a name="l01589"></a><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html">01589</a> <span class="keyword">class </span><a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html">Response</a>(dict):
<a name="l01590"></a>01590     <span class="stringliteral">&quot;&quot;&quot;An object more like email.Message than httplib.HTTPResponse.&quot;&quot;&quot;</span>
<a name="l01591"></a>01591 
<a name="l01592"></a>01592     <span class="stringliteral">&quot;&quot;&quot;Is this response from our local cache&quot;&quot;&quot;</span>
<a name="l01593"></a>01593     fromcache = <span class="keyword">False</span>
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     <span class="stringliteral">&quot;&quot;&quot;HTTP protocol version used by server. 10 for HTTP/1.0, 11 for HTTP/1.1. &quot;&quot;&quot;</span>
<a name="l01596"></a>01596     version = 11
<a name="l01597"></a>01597 
<a name="l01598"></a>01598     <span class="stringliteral">&quot;Status code returned by server. &quot;</span>
<a name="l01599"></a>01599     status = 200
<a name="l01600"></a>01600 
<a name="l01601"></a>01601     <span class="stringliteral">&quot;&quot;&quot;Reason phrase returned by server.&quot;&quot;&quot;</span>
<a name="l01602"></a>01602     reason = <span class="stringliteral">&quot;Ok&quot;</span>
<a name="l01603"></a>01603 
<a name="l01604"></a>01604     previous = <span class="keywordtype">None</span>
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     <span class="keyword">def </span>__init__(self, info):
<a name="l01607"></a>01607         <span class="comment"># info is either an email.Message or</span>
<a name="l01608"></a>01608         <span class="comment"># an httplib.HTTPResponse object.</span>
<a name="l01609"></a>01609         <span class="keywordflow">if</span> isinstance(info, httplib.HTTPResponse):
<a name="l01610"></a>01610             <span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> info.getheaders():
<a name="l01611"></a>01611                 self[key.lower()] = value
<a name="l01612"></a>01612             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#a6fa81fea55627cd1f4f818f2d618bce2">status</a> = info.status
<a name="l01613"></a>01613             self[<span class="stringliteral">&#39;status&#39;</span>] = str(self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#a6fa81fea55627cd1f4f818f2d618bce2">status</a>)
<a name="l01614"></a>01614             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#ae9df1b0efffb0e7006bf532a4375bf48">reason</a> = info.reason
<a name="l01615"></a>01615             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#a25f501cd4b441460dab198d4e03211f6">version</a> = info.version
<a name="l01616"></a>01616         <span class="keywordflow">elif</span> isinstance(info, email.Message.Message):
<a name="l01617"></a>01617             <span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> info.items():
<a name="l01618"></a>01618                 self[key] = value
<a name="l01619"></a>01619             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#a6fa81fea55627cd1f4f818f2d618bce2">status</a> = int(self[<span class="stringliteral">&#39;status&#39;</span>])
<a name="l01620"></a>01620         <span class="keywordflow">else</span>:
<a name="l01621"></a>01621             <span class="keywordflow">for</span> key, value <span class="keywordflow">in</span> info.iteritems():
<a name="l01622"></a>01622                 self[key] = value
<a name="l01623"></a>01623             self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#a6fa81fea55627cd1f4f818f2d618bce2">status</a> = int(self.get(<span class="stringliteral">&#39;status&#39;</span>, self.<a class="code" href="classPlurk_1_1oauth2_1_1httplib2_1_1Response.html#a6fa81fea55627cd1f4f818f2d618bce2">status</a>))
<a name="l01624"></a>01624 
<a name="l01625"></a>01625 
<a name="l01626"></a>01626     <span class="keyword">def </span>__getattr__(self, name):
<a name="l01627"></a>01627         <span class="keywordflow">if</span> name == <span class="stringliteral">&#39;dict&#39;</span>:
<a name="l01628"></a>01628             <span class="keywordflow">return</span> self
<a name="l01629"></a>01629         <span class="keywordflow">else</span>:
<a name="l01630"></a>01630             <span class="keywordflow">raise</span> AttributeError, name
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Jun 24 2012 20:50:11 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
